---
title: 'Schema'
description: 'Schema definition and management system for structured attestations'
icon: 'table-list'
---

## Overview

Schemas define the structure and format of attestation data in the AttestProtocol system. They provide standardized templates that ensure consistent data formats and enable interoperability between different applications and authorities.

## Core Concepts

### Schema Definition
Schemas specify the data fields, types, and validation rules for attestations. They act as contracts between attestation issuers and consumers, ensuring data consistency and enabling automatic validation.

### Schema Ownership
Each schema is owned by the authority that created it. Schema ownership determines who can modify schema properties and manage schema lifecycle.

### Schema Immutability
Once created, core schema definitions are immutable to ensure attestation data integrity. This prevents retroactive changes that could invalidate existing attestations.

---

## Methods

### createSchema()

Creates a new attestation schema with specified structure and properties.

**Purpose:** Define a reusable template for attestations with consistent data structure and validation rules.

**Chain Differences:**
- **Stellar:** Simple schema creation with resolver and revocability options
- **Solana:** Advanced schema creation with levy configuration and PDA management

**Parameters:**

**Stellar:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaName` | `string` | Yes | Unique schema identifier |
| `schemaContent` | `string` | Yes | Schema field definitions |
| `resolverAddress` | `string` | No | Resolver contract address |
| `revocable` | `boolean` | No | Enable attestation revocation (default: true) |

**Solana:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaName` | `string` | Yes | Unique schema identifier |
| `schemaContent` | `string` | Yes | Schema field definitions |
| `resolverAddress` | `PublicKey` | No | Resolver program address |
| `revocable` | `boolean` | No | Enable attestation revocation |
| `levy` | `LevyConfig` | No | Fee configuration for attestations |

**Levy Configuration (Solana):**
```typescript
interface LevyConfig {
  amount: anchor.BN;              // Fee amount in lamports
  asset?: anchor.web3.PublicKey;  // Token mint (defaults to SOL)
  recipient?: anchor.web3.PublicKey; // Fee recipient
}
```

**Returns:**

**Stellar:**
```typescript
AttestSDKResponse<StellarCreateSchemaResult>

interface StellarCreateSchemaResult {
  schemaUID: string;  // Transaction hash as hex string
  hash: string;       // Transaction hash
}
```

**Solana:**
```typescript
AttestSDKResponse<anchor.web3.PublicKey>  // Schema PDA
```

**Usage Example:**
```typescript
// Stellar schema creation
const stellarResult = await stellarSDK.createSchema({
  schemaName: 'kyc-verification',
  schemaContent: 'verified:bool,level:string,score:uint8,timestamp:uint64',
  revocable: true
});

// Solana schema with levy
const solanaResult = await solanaSDK.createSchema({
  schemaName: 'reputation-score',
  schemaContent: 'score:u8,category:string,verified_at:u64',
  revocable: true,
  levy: {
    amount: new anchor.BN(1000000), // 0.001 SOL
    asset: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112')
  }
});
```

**Schema Content Format:**
Schema content follows a structured format specifying field names and types:
- Format: `field_name:type,field_name:type`
- Types: `bool`, `string`, `uint8`, `uint64`, `bytes`, `address`
- Example: `verified:bool,score:uint8,metadata:string`

---

### fetchSchema()

Retrieves schema definition and metadata by UID.

**Purpose:** Get schema structure and properties for attestation creation or validation.

**Parameters:**

| Chain | Parameter Type | Description |
|-------|----------------|-------------|
| **Stellar** | `string` | 64-character hex string (transaction hash) |
| **Solana** | `PublicKey` | Schema PDA address |

**Returns:**

**Stellar:**
```typescript
AttestSDKResponse<StellarFetchSchemaResult | null>

interface StellarFetchSchemaResult {
  uid: string;              // Schema UID
  definition: string;       // Schema field definitions
  authority: string;        // Schema creator address
  revocable: boolean;       // Revocation capability
  resolver: string | null;  // Resolver address
}
```

**Solana:**
```typescript
AttestSDKResponse<SolanaFetchSchemaResult | null>

interface SolanaFetchSchemaResult {
  uid: anchor.web3.PublicKey;       // Schema PDA
  schema: string;                   // Schema field definitions
  resolver?: anchor.web3.PublicKey; // Resolver program
  revocable: boolean;               // Revocation capability
  deployer: anchor.web3.PublicKey;  // Schema creator
  levy?: {                          // Fee configuration
    amount: anchor.BN;
    asset: anchor.web3.PublicKey;
    recipient: anchor.web3.PublicKey;
  };
}
```

**Usage Example:**
```typescript
// Stellar schema fetch
const stellarResult = await stellarSDK.fetchSchema('abc123def456...');

// Solana schema fetch
const solanaResult = await solanaSDK.fetchSchema(schemaPDA);

if (result.data) {
  const schema = result.data;
  // Parse schema.definition for field structure
  const fields = parseSchemaDefinition(schema.definition);
}
```

---

## Schema Structure

### Field Types

| Type | Description | Example Values |
|------|-------------|----------------|
| `bool` | Boolean true/false | `true`, `false` |
| `string` | Text data | `"verified"`, `"premium"` |
| `uint8` | 8-bit unsigned integer | `0-255` |
| `uint64` | 64-bit unsigned integer | `1704067200` |
| `bytes` | Binary data | `0x1234abcd` |
| `address` | Blockchain address | Chain-specific format |

### Schema Examples

**KYC Verification Schema:**
```
verified:bool,level:string,score:uint8,timestamp:uint64
```

**Reputation System Schema:**
```
score:uint8,category:string,endorsements:uint64,verified_at:uint64
```

**Certificate Schema:**
```
certified:bool,issuer:string,valid_until:uint64,metadata:bytes
```

**Identity Verification Schema:**
```
identity_verified:bool,document_type:string,verification_level:uint8,expires:uint64
```

---

## Schema Properties

### Revocability
Controls whether attestations created with this schema can be revoked:
- **True:** Attestations can be revoked by the issuing authority
- **False:** Attestations are permanent and cannot be revoked
- **Default:** True (revocable)

### Resolver Integration
Schemas can specify resolver contracts/programs for additional validation:
- **Stellar:** Resolver contract address for custom validation logic
- **Solana:** Resolver program for cross-program validation
- **Optional:** Schemas work without resolvers

### Levy System (Solana)
Schemas can specify fees for attestation creation:
- **Amount:** Fee in lamports or token units
- **Asset:** SOL or SPL token mint address
- **Recipient:** Address receiving levy payments
- **Purpose:** Spam prevention, revenue generation, or staking requirements

---

## Schema Lifecycle

### Creation Process
1. **Authority Check:** Verify caller is registered authority
2. **Name Validation:** Ensure schema name is unique for authority
3. **Content Validation:** Parse and validate schema definition
4. **On-Chain Storage:** Store schema data immutably
5. **UID Generation:** Return unique schema identifier

### Schema Immutability
Core schema properties cannot be modified after creation:
- Schema definition (field structure)
- Revocability setting
- Levy configuration (Solana)

### Schema Evolution
New schema versions can be created with different names:
- `kyc-verification-v1`
- `kyc-verification-v2`
- Applications choose which version to use

---

## Chain-Specific Features

### Stellar Schema Features
- **Transaction Hash UIDs:** Schema UIDs are transaction hashes
- **String-Based Addresses:** All addresses stored as strings
- **Contract Integration:** Soroban contract storage
- **Network Dependency:** Currently testnet only

### Solana Schema Features
- **PDA Management:** Schemas stored in Program Derived Addresses
- **Token Integration:** Native SPL token support for levies
- **Cross-Program Calls:** Resolver program invocation
- **Multi-Network:** Devnet, testnet, and mainnet support

---

## Integration Patterns

### Schema Registry
```typescript
class SchemaRegistry {
  private schemas: Map<string, any> = new Map();

  async getSchema(uid: string, sdk: any): Promise<any> {
    if (this.schemas.has(uid)) {
      return this.schemas.get(uid);
    }

    const result = await sdk.fetchSchema(uid);
    if (result.data) {
      this.schemas.set(uid, result.data);
      return result.data;
    }

    return null;
  }

  parseSchemaDefinition(definition: string): SchemaField[] {
    return definition.split(',').map(field => {
      const [name, type] = field.split(':');
      return { name: name.trim(), type: type.trim() };
    });
  }
}
```

### Schema Validation
```typescript
interface SchemaField {
  name: string;
  type: string;
}

function validateAttestatationData(
  data: Record<string, any>,
  schema: SchemaField[]
): boolean {
  for (const field of schema) {
    const value = data[field.name];
    
    if (!validateFieldType(value, field.type)) {
      return false;
    }
  }
  
  return true;
}

function validateFieldType(value: any, type: string): boolean {
  switch (type) {
    case 'bool': return typeof value === 'boolean';
    case 'string': return typeof value === 'string';
    case 'uint8': return Number.isInteger(value) && value >= 0 && value <= 255;
    case 'uint64': return Number.isInteger(value) && value >= 0;
    default: return false;
  }
}
```

### Multi-Chain Schema Management
```typescript
interface SchemaManager {
  stellar?: Map<string, StellarFetchSchemaResult>;
  solana?: Map<string, SolanaFetchSchemaResult>;
}

async function syncSchemas(
  stellarSDK: StellarAttestSDK,
  solanaSDK: SolanaAttestSDK,
  schemaNames: string[]
): Promise<SchemaManager> {
  const manager: SchemaManager = {
    stellar: new Map(),
    solana: new Map()
  };

  // Fetch schemas from both chains
  const stellarPromises = schemaNames.map(name => 
    stellarSDK.fetchSchema(name)
  );
  
  const solanaPromises = schemaNames.map(name =>
    solanaSDK.fetchSchema(new anchor.web3.PublicKey(name))
  );

  const [stellarResults, solanaResults] = await Promise.all([
    Promise.all(stellarPromises),
    Promise.all(solanaPromises)
  ]);

  // Process results
  stellarResults.forEach((result, index) => {
    if (result.data) {
      manager.stellar!.set(schemaNames[index], result.data);
    }
  });

  solanaResults.forEach((result, index) => {
    if (result.data) {
      manager.solana!.set(schemaNames[index], result.data);
    }
  });

  return manager;
}
```

---

## Error Handling

### Common Schema Errors

| Error | Description | Chain | Solution |
|-------|-------------|-------|----------|
| **Schema Already Exists** | Name collision | Solana | Use different schema name |
| **Invalid Schema Format** | Malformed definition | Both | Fix schema content format |
| **Authority Not Registered** | Creator not authority | Both | Register as authority first |
| **Invalid UID Format** | Wrong UID format | Stellar | Use 64-character hex string |
| **Insufficient Balance** | Can't pay fees/rent | Both | Add more tokens to wallet |

### Error Handling Pattern
```typescript
async function createSchemaWithRetry(
  sdk: any,
  config: any,
  maxRetries: number = 3
): Promise<any> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const result = await sdk.createSchema(config);
    
    if (!result.error) {
      return result.data;
    }

    // Handle specific errors
    if (result.error.code === 6010) { // SchemaAlreadyExists
      config.schemaName = `${config.schemaName}-v${attempt}`;
      continue;
    }

    if (result.error.message?.includes('insufficient')) {
      throw new Error('Insufficient balance for schema creation');
    }

    if (attempt === maxRetries) {
      throw new Error(`Schema creation failed after ${maxRetries} attempts: ${result.error}`);
    }

    // Wait before retry
    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
  }
}
```

---

## Best Practices

### Schema Design
- Use descriptive field names and consistent naming conventions
- Include version numbers in schema names for evolution
- Specify appropriate data types for validation
- Document schema purpose and field meanings

### Schema Management
- Cache frequently used schemas to reduce network calls
- Implement schema versioning strategies
- Validate attestation data against schema structure
- Handle schema fetch failures gracefully

### Performance Optimization
- Batch schema operations when possible
- Use schema registries to avoid duplicate fetches
- Implement proper error handling and retry logic
- Consider schema complexity impact on gas costs