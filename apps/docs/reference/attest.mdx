---
title: 'Attestation'
description: 'Attestation creation, management, and lifecycle operations'
icon: 'certificate'
---

## Overview

Attestations are verifiable claims made by authorities about subjects using predefined schemas. They form the core of the AttestProtocol system, enabling decentralized reputation, identity verification, and trust mechanisms across blockchain networks.

## Core Concepts

### Attestation Structure
Each attestation contains structured data that conforms to a specific schema, linking an authority (issuer), subject (target), and claim data with cryptographic proof and timestamp information.

### Immutable Claims
Once created, attestation data cannot be modified. This immutability ensures the integrity of claims and prevents retroactive manipulation of reputation or verification data.

### Revocation System
Attestations can be revoked by their issuing authority (if the schema allows), providing a mechanism to invalidate claims when circumstances change or errors are discovered.

---

## Methods

### attest()

Creates a new attestation linking a subject to specific claim data.

**Purpose:** Issue a verifiable claim about a subject using a predefined schema structure.

**Chain Behavior:**
- **Stellar:** Simple attestation with schema UID, subject, value, and reference
- **Solana:** Complex attestation with account management, expiration, and levy handling

**Parameters:**

**Stellar:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaUID` | `string` | Yes | 64-character hex schema identifier |
| `subject` | `string` | Yes | Stellar address being attested about |
| `value` | `string` | Yes | Attestation data matching schema format |
| `reference` | `string` | Yes | Unique reference identifier |

**Solana:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaData` | `PublicKey` | Yes | Schema PDA reference |
| `data` | `string` | Yes | Attestation data matching schema format |
| `refUID` | `PublicKey` | No | Reference to another attestation |
| `expirationTime` | `number` | No | Unix timestamp expiration |
| `revocable` | `boolean` | No | Override schema revocability |
| `accounts` | `object` | Yes | Required account addresses |

**Solana Accounts Object:**
```typescript
interface AttestationAccounts {
  recipient: anchor.web3.PublicKey;      // Subject being attested about
  levyReceipent: anchor.web3.PublicKey;  // Fee recipient (note: typo in implementation)
  mintAccount: anchor.web3.PublicKey;    // Token mint for levy payment
}
```

**Returns:**

**Stellar:**
```typescript
AttestSDKResponse<string>  // Transaction hash
```

**Solana:**
```typescript
AttestSDKResponse<anchor.web3.PublicKey>  // Attestation PDA
```

**Usage Example:**
```typescript
// Stellar attestation
const stellarResult = await stellarSDK.attest({
  schemaUID: 'abc123def456...',
  subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
  value: 'verified:true,level:enhanced,score:95,timestamp:1704067200',
  reference: 'kyc-check-2024-001'
});

// Solana attestation with expiration
const solanaResult = await solanaSDK.attest({
  schemaData: schemaPDA,
  data: 'score:85,category:defi,verified_at:1704067200',
  expirationTime: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60), // 1 year
  revocable: true,
  accounts: {
    recipient: new anchor.web3.PublicKey('...'),
    levyReceipent: authorityWallet,
    mintAccount: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112')
  }
});
```

**Data Format:**
Attestation data must match the schema format:
- Format: `field_name:value,field_name:value`
- Values must match schema field types
- Example: `verified:true,score:95,level:enhanced`

---

### fetchAttestation()

Retrieves attestation data and metadata by identifier.

**Purpose:** Get complete attestation information including data, timestamps, and revocation status.

**Parameters:**

**Stellar:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaUID` | `string` | Yes | 64-character hex schema identifier |
| `subject` | `string` | Yes | Stellar address |
| `reference` | `string` | No | Reference identifier for lookup |

**Solana:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `attestation` | `PublicKey` or `string` | Yes | Attestation PDA or identifier |

**Returns:**

**Stellar:**
```typescript
AttestSDKResponse<StellarFetchAttestationResult | null>

interface StellarFetchAttestationResult {
  schemaUid: string;         // Schema identifier
  subject: string;           // Subject address
  value: string;             // Attestation data
  reference: string | null;  // Reference identifier
  revoked: boolean;          // Revocation status
}
```

**Solana:**
```typescript
AttestSDKResponse<SolanaFetchAttestationResult | null>

interface SolanaFetchAttestationResult {
  schema: anchor.web3.PublicKey;      // Schema PDA
  recipient: anchor.web3.PublicKey;   // Subject address  
  attester: anchor.web3.PublicKey;    // Authority who issued
  data: string;                       // Attestation data
  time: anchor.BN;                    // Creation timestamp
  refUid: anchor.web3.PublicKey;      // Reference attestation
  expirationTime: anchor.BN;          // Expiration timestamp
  revocationTime: anchor.BN;          // Revocation timestamp (0 if not revoked)
  revocable: boolean;                 // Can be revoked flag
  uid: anchor.web3.PublicKey;         // Attestation PDA
}
```

**Usage Example:**
```typescript
// Stellar fetch by schema, subject, and reference
const stellarResult = await stellarSDK.fetchAttestation({
  schemaUID: 'abc123def456...',
  subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
  reference: 'kyc-check-2024-001'
});

// Solana fetch by PDA
const solanaResult = await solanaSDK.fetchAttestation(attestationPDA);

if (result.data && !result.data.revoked) {
  // Attestation exists and is not revoked
  const attestation = result.data;
  
  // Parse attestation data
  const parsedData = parseAttestationData(attestation.data || attestation.value);
}
```

---

### revokeAttestation()

Revokes an existing attestation, marking it as invalid.

**Purpose:** Invalidate a previously issued attestation when circumstances change or errors are discovered.

**Authority Requirement:** Only the original issuing authority can revoke their attestations.

**Parameters:**

**Stellar:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `schemaUID` | `string` | Yes | 64-character hex schema identifier |
| `subject` | `string` | Yes | Stellar address |
| `reference` | `string` | No | Reference identifier |

**Solana:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `attestationUID` | `PublicKey` | Yes | Attestation PDA to revoke |
| `recipient` | `PublicKey` | Yes | Subject address |
| `reference` | `string` | No | Reference identifier |

**Returns:**

**Stellar:**
```typescript
AttestSDKResponse<string>  // Revocation transaction hash
```

**Solana:**
```typescript
AttestSDKResponse<anchor.web3.PublicKey>  // Attestation PDA
```

**Usage Example:**
```typescript
// Stellar revocation
const stellarResult = await stellarSDK.revokeAttestation({
  schemaUID: 'abc123def456...',
  subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
  reference: 'kyc-check-2024-001'
});

// Solana revocation
const solanaResult = await solanaSDK.revokeAttestation({
  attestationUID: attestationPDA,
  recipient: subjectPubkey,
  reference: 'revocation-2024-001'
});
```

**Revocation Effects:**
- Sets attestation status to revoked
- Records revocation timestamp
- Prevents future use for verification
- Maintains historical record for audit

---

## Attestation Lifecycle

### Creation Process
1. **Authority Verification:** Confirm issuer is registered authority
2. **Schema Validation:** Verify schema exists and data conforms
3. **Subject Validation:** Confirm subject address format
4. **Levy Payment:** Handle fees if schema requires payment (Solana)
5. **On-Chain Storage:** Store attestation data immutably
6. **Event Emission:** Broadcast attestation creation event

### Active State
- Attestation is valid and can be used for verification
- Subject can reference attestation for reputation/identity
- Data remains immutable and cryptographically verifiable
- Expiration time (if set) determines validity period

### Revocation Process
1. **Authority Check:** Verify revoker is original issuer
2. **Revocability Check:** Confirm schema allows revocation
3. **Status Update:** Mark attestation as revoked
4. **Timestamp Recording:** Record exact revocation time
5. **Event Emission:** Broadcast revocation event

### Expired State (Solana)
- Attestation automatically becomes invalid after expiration time
- No explicit revocation needed
- Status can be checked programmatically
- Historical data remains accessible

---

## Chain-Specific Features

### Stellar Attestation Features
- **Transaction Hash References:** Uses blockchain transactions as proof
- **Simple Data Model:** String-based data and addresses
- **Reference System:** Optional reference strings for organization
- **Contract Storage:** Data stored in Soroban contracts

### Solana Attestation Features
- **PDA Management:** Each attestation gets unique Program Derived Address
- **Timestamp Precision:** Unix timestamp creation and expiration times
- **Reference Linking:** Attestations can reference other attestations
- **Token Integration:** Levy payments using SOL or SPL tokens
- **Rich Metadata:** Comprehensive attestation metadata on-chain

---

## Data Formats

### Attestation Data Structure
```typescript
// Schema: verified:bool,level:string,score:uint8,timestamp:uint64
// Data:   verified:true,level:enhanced,score:95,timestamp:1704067200

interface ParsedAttestationData {
  verified: boolean;
  level: string;
  score: number;
  timestamp: number;
}
```

### Data Parsing Utility
```typescript
function parseAttestationData(data: string): Record<string, any> {
  const parsed: Record<string, any> = {};
  
  data.split(',').forEach(pair => {
    const [key, value] = pair.split(':');
    
    // Type inference based on value format
    if (value === 'true' || value === 'false') {
      parsed[key] = value === 'true';
    } else if (/^\d+$/.test(value)) {
      parsed[key] = parseInt(value);
    } else {
      parsed[key] = value;
    }
  });
  
  return parsed;
}
```

---

## Integration Patterns

### Attestation Verification
```typescript
async function verifyAttestation(
  sdk: any,
  attestationId: string | PublicKey,
  requiredFields?: Record<string, any>
): Promise<boolean> {
  const result = await sdk.fetchAttestation(attestationId);
  
  if (result.error || !result.data) {
    return false;
  }
  
  const attestation = result.data;
  
  // Check if revoked
  if (attestation.revoked || attestation.revocationTime?.gt(new anchor.BN(0))) {
    return false;
  }
  
  // Check expiration (Solana)
  if (attestation.expirationTime) {
    const now = Math.floor(Date.now() / 1000);
    if (attestation.expirationTime.lt(new anchor.BN(now))) {
      return false;
    }
  }
  
  // Validate required fields
  if (requiredFields) {
    const data = parseAttestationData(attestation.data || attestation.value);
    for (const [field, expectedValue] of Object.entries(requiredFields)) {
      if (data[field] !== expectedValue) {
        return false;
      }
    }
  }
  
  return true;
}
```

### Batch Attestation Creation
```typescript
async function createBatchAttestations(
  sdk: any,
  schemaPDA: PublicKey,
  subjects: Array<{ address: PublicKey; data: string }>,
  accounts: AttestationAccounts
): Promise<PublicKey[]> {
  const promises = subjects.map(subject =>
    sdk.attest({
      schemaData: schemaPDA,
      data: subject.data,
      accounts: {
        ...accounts,
        recipient: subject.address
      }
    })
  );
  
  const results = await Promise.all(promises);
  
  return results
    .filter(result => !result.error)
    .map(result => result.data);
}
```

### Attestation Registry
```typescript
class AttestationRegistry {
  private attestations: Map<string, any> = new Map();
  
  async getAttestation(id: string, sdk: any): Promise<any> {
    // Check cache first
    if (this.attestations.has(id)) {
      return this.attestations.get(id);
    }
    
    // Fetch from chain
    const result = await sdk.fetchAttestation(id);
    if (result.data) {
      this.attestations.set(id, result.data);
      return result.data;
    }
    
    return null;
  }
  
  async getAttestationsBySubject(
    subject: string | PublicKey,
    schemas: string[],
    sdk: any
  ): Promise<any[]> {
    // Implementation depends on indexing solution
    // This would typically involve external indexer or event filtering
    const attestations: any[] = [];
    
    for (const schema of schemas) {
      try {
        const result = await sdk.fetchAttestation({
          schemaUID: schema,
          subject: subject.toString()
        });
        
        if (result.data && !result.data.revoked) {
          attestations.push(result.data);
        }
      } catch (error) {
        // Handle individual fetch failures
        continue;
      }
    }
    
    return attestations;
  }
}
```

---

## Error Handling

### Common Attestation Errors

| Error | Description | Chain | Solution |
|-------|-------------|-------|----------|
| **Schema Not Found** | Invalid schema UID | Both | Verify schema exists |
| **Data Format Mismatch** | Data doesn't match schema | Both | Fix data format |
| **Already Revoked** | Attestation already revoked | Solana | Check revocation status first |
| **Not Revocable** | Schema doesn't allow revocation | Both | Check schema properties |
| **Insufficient Balance** | Can't pay transaction fees | Both | Add more tokens |
| **Attestation Not Found** | Invalid attestation identifier | Both | Verify attestation exists |
| **Unauthorized** | Not the issuing authority | Both | Use correct authority wallet |

### Error Handling Patterns
```typescript
async function createAttestationSafe(
  sdk: any,
  config: any
): Promise<string | PublicKey | null> {
  try {
    const result = await sdk.attest(config);
    
    if (result.error) {
      // Handle specific errors
      if (result.error.code === 6000) { // InvalidSchema
        throw new Error('Schema format is invalid');
      }
      
      if (result.error.code === 6005) { // DataTooLarge
        throw new Error('Attestation data exceeds size limits');
      }
      
      if (result.error.message?.includes('insufficient')) {
        throw new Error('Insufficient balance for attestation');
      }
      
      throw new Error(`Attestation failed: ${result.error.message || result.error}`);
    }
    
    return result.data;
  } catch (error) {
    console.error('Attestation creation error:', error);
    return null;
  }
}
```

---

## Performance Considerations

### Gas Optimization
- **Stellar:** Minimize transaction operations, batch when possible
- **Solana:** Optimize account usage, consider compute unit limits
- **Data Size:** Keep attestation data concise to reduce costs

### Network Efficiency
- Cache frequently accessed attestations
- Use indexing services for queries
- Implement retry logic for network failures
- Batch operations when creating multiple attestations

### Storage Patterns
- Use consistent data formats for parsing efficiency
- Consider data compression for large attestations
- Implement proper error handling for failed fetches
- Use appropriate expiration times to manage storage costs

---

## Best Practices

### Data Management
- Validate data format against schema before attestation
- Use consistent field naming and value formats
- Include timestamps for time-sensitive claims
- Document data semantics for consumer clarity

### Security
- Verify authority credentials before trusting attestations
- Check revocation status for critical decisions
- Validate expiration times for time-sensitive attestations
- Implement proper access controls for attestation queries

### User Experience
- Provide clear feedback on attestation status
- Handle network delays gracefully
- Cache attestations for responsive interfaces
- Implement proper error messages for failed operations