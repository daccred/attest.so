---
title: 'Administration'
description: 'Authority management, governance, and administrative operations'
icon: 'user-gear'
---

## Overview

Administration encompasses authority management, system governance, and administrative operations within the AttestProtocol ecosystem. This includes managing authority permissions, monitoring system health, and handling governance decisions.

---

## Authority Management

### Authority Registration Process

**Stellar Authority Registration:**

| Step | Action | Result |
|------|--------|--------|
| 1 | Call `registerAuthority()` | Creates authority record in protocol contract |
| 2 | Transaction confirmation | Authority address returned |
| 3 | Verification (optional) | Enhanced trust status |

**Solana Authority Registration:**

| Step | Action | Result |
|------|--------|--------|
| 1 | Call `registerAuthority()` | Creates authority PDA account |
| 2 | Account creation | Authority PDA with metadata |
| 3 | Verification process | `isVerified` flag updated |

### Authority Status Management

```typescript
interface AuthorityStatus {
  registered: boolean;
  verified: boolean;
  activeSchemas: number;
  totalAttestations: number;
  reputation: number;
  registrationDate: Date;
}

async function getAuthorityStatus(
  sdk: StellarAttestSDK | SolanaAttestSDK
): Promise<AuthorityStatus> {
  const result = await sdk.fetchAuthority();
  
  if (result.error || !result.data) {
    return {
      registered: false,
      verified: false,
      activeSchemas: 0,
      totalAttestations: 0,
      reputation: 0,
      registrationDate: new Date()
    };
  }

  // Platform-specific status extraction
  if ('isVerified' in result.data) {
    // Solana implementation
    return {
      registered: true,
      verified: result.data.isVerified,
      activeSchemas: 0, // Would need additional query
      totalAttestations: 0, // Would need additional query
      reputation: result.data.isVerified ? 100 : 50,
      registrationDate: new Date(result.data.firstDeployment.toNumber() * 1000)
    };
  } else {
    // Stellar implementation
    return {
      registered: true,
      verified: result.data.metadata?.includes('verified') || false,
      activeSchemas: 0, // Would need additional query
      totalAttestations: 0, // Would need additional query
      reputation: 75, // Based on metadata analysis
      registrationDate: new Date() // Would need timestamp from metadata
    };
  }
}
```

---

## Multi-Authority Coordination

### Authority Groups

```typescript
interface AuthorityGroup {
  name: string;
  members: string[];
  permissions: string[];
  consensusThreshold: number;
}

class AuthorityGroupManager {
  private groups: Map<string, AuthorityGroup> = new Map();

  createGroup(
    name: string, 
    members: string[], 
    permissions: string[],
    threshold: number = Math.ceil(members.length / 2)
  ): AuthorityGroup {
    const group: AuthorityGroup = {
      name,
      members,
      permissions,
      consensusThreshold: threshold
    };
    
    this.groups.set(name, group);
    return group;
  }

  async executeGroupAction(
    groupName: string,
    action: () => Promise<any>,
    approvals: string[]
  ): Promise<any> {
    const group = this.groups.get(groupName);
    if (!group) {
      throw new Error('Group not found');
    }

    if (approvals.length < group.consensusThreshold) {
      throw new Error('Insufficient approvals');
    }

    // Verify all approvers are group members
    const validApprovals = approvals.filter(approval => 
      group.members.includes(approval)
    );

    if (validApprovals.length < group.consensusThreshold) {
      throw new Error('Invalid approvers');
    }

    return await action();
  }
}
```

### Delegation Management

```typescript
interface DelegationConfig {
  delegator: string;
  delegate: string;
  permissions: string[];
  expiresAt: Date;
  revocable: boolean;
}

class DelegationManager {
  private delegations: Map<string, DelegationConfig> = new Map();

  createDelegation(config: DelegationConfig): string {
    const delegationId = this.generateDelegationId(config);
    this.delegations.set(delegationId, config);
    return delegationId;
  }

  async executeWithDelegation(
    delegationId: string,
    action: string,
    executor: string
  ): Promise<boolean> {
    const delegation = this.delegations.get(delegationId);
    
    if (!delegation) {
      throw new Error('Delegation not found');
    }

    if (delegation.expiresAt < new Date()) {
      throw new Error('Delegation expired');
    }

    if (delegation.delegate !== executor) {
      throw new Error('Unauthorized executor');
    }

    if (!delegation.permissions.includes(action)) {
      throw new Error('Action not permitted');
    }

    return true;
  }

  revokeDelegation(delegationId: string, revoker: string): boolean {
    const delegation = this.delegations.get(delegationId);
    
    if (!delegation) {
      return false;
    }

    if (!delegation.revocable) {
      throw new Error('Delegation not revocable');
    }

    if (delegation.delegator !== revoker) {
      throw new Error('Only delegator can revoke');
    }

    this.delegations.delete(delegationId);
    return true;
  }

  private generateDelegationId(config: DelegationConfig): string {
    return `${config.delegator}_${config.delegate}_${Date.now()}`;
  }
}
```

---

## System Monitoring

### Health Monitoring

```typescript
interface SystemHealth {
  rpcStatus: 'healthy' | 'degraded' | 'down';
  contractStatus: 'operational' | 'maintenance' | 'error';
  transactionVolume: number;
  errorRate: number;
  averageResponseTime: number;
  lastCheck: Date;
}

class HealthMonitor {
  async checkSystemHealth(
    sdk: StellarAttestSDK | SolanaAttestSDK
  ): Promise<SystemHealth> {
    const startTime = Date.now();
    let rpcStatus: SystemHealth['rpcStatus'] = 'healthy';
    let contractStatus: SystemHealth['contractStatus'] = 'operational';
    let errorCount = 0;
    let totalChecks = 0;

    try {
      // Test basic connectivity
      const authorityResult = await sdk.fetchAuthority();
      totalChecks++;
      
      if (authorityResult.error) {
        errorCount++;
        if (authorityResult.error.message?.includes('network')) {
          rpcStatus = 'down';
        } else {
          contractStatus = 'error';
        }
      }

      // Test schema operations
      try {
        // This would fail for non-existent schema, which is expected
        await sdk.fetchSchema('test');
        totalChecks++;
      } catch (error) {
        totalChecks++;
        // Expected error for non-existent schema
      }

    } catch (error) {
      errorCount++;
      rpcStatus = 'down';
    }

    const responseTime = Date.now() - startTime;
    const errorRate = errorCount / totalChecks;

    if (errorRate > 0.5) {
      rpcStatus = 'degraded';
    }

    return {
      rpcStatus,
      contractStatus,
      transactionVolume: 0, // Would need historical data
      errorRate,
      averageResponseTime: responseTime,
      lastCheck: new Date()
    };
  }
}
```

### Performance Metrics

```typescript
interface PerformanceMetrics {
  operationType: string;
  successCount: number;
  errorCount: number;
  averageLatency: number;
  p95Latency: number;
  throughput: number; // operations per second
  period: string;
}

class MetricsCollector {
  private metrics: Map<string, number[]> = new Map();

  recordOperation(operation: string, latency: number, success: boolean) {
    const key = `${operation}_${success ? 'success' : 'error'}`;
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }
    
    this.metrics.get(key)!.push(latency);
  }

  getMetrics(operation: string, periodHours: number = 1): PerformanceMetrics {
    const successKey = `${operation}_success`;
    const errorKey = `${operation}_error`;
    
    const successLatencies = this.metrics.get(successKey) || [];
    const errorLatencies = this.metrics.get(errorKey) || [];
    
    const allLatencies = [...successLatencies, ...errorLatencies];
    const sortedLatencies = allLatencies.sort((a, b) => a - b);
    
    const p95Index = Math.floor(sortedLatencies.length * 0.95);
    
    return {
      operationType: operation,
      successCount: successLatencies.length,
      errorCount: errorLatencies.length,
      averageLatency: allLatencies.reduce((a, b) => a + b, 0) / allLatencies.length || 0,
      p95Latency: sortedLatencies[p95Index] || 0,
      throughput: allLatencies.length / (periodHours * 3600),
      period: `${periodHours}h`
    };
  }
}
```

---

## Governance Operations

### Schema Governance

```typescript
interface SchemaGovernanceConfig {
  approvalThreshold: number;
  votingPeriod: number; // in seconds
  quorumRequirement: number;
}

interface SchemaProposal {
  id: string;
  proposer: string;
  schemaDefinition: string;
  description: string;
  votes: Map<string, 'approve' | 'reject'>;
  createdAt: Date;
  expiresAt: Date;
  status: 'pending' | 'approved' | 'rejected' | 'expired';
}

class SchemaGovernance {
  private proposals: Map<string, SchemaProposal> = new Map();
  private config: SchemaGovernanceConfig;
  private authorities: Set<string>;

  constructor(config: SchemaGovernanceConfig, authorities: string[]) {
    this.config = config;
    this.authorities = new Set(authorities);
  }

  createProposal(
    proposer: string,
    schemaDefinition: string,
    description: string
  ): string {
    if (!this.authorities.has(proposer)) {
      throw new Error('Only authorities can create proposals');
    }

    const proposalId = `proposal_${Date.now()}`;
    const proposal: SchemaProposal = {
      id: proposalId,
      proposer,
      schemaDefinition,
      description,
      votes: new Map(),
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + this.config.votingPeriod * 1000),
      status: 'pending'
    };

    this.proposals.set(proposalId, proposal);
    return proposalId;
  }

  vote(proposalId: string, voter: string, vote: 'approve' | 'reject'): boolean {
    if (!this.authorities.has(voter)) {
      throw new Error('Only authorities can vote');
    }

    const proposal = this.proposals.get(proposalId);
    if (!proposal) {
      throw new Error('Proposal not found');
    }

    if (proposal.status !== 'pending') {
      throw new Error('Proposal not active');
    }

    if (new Date() > proposal.expiresAt) {
      proposal.status = 'expired';
      throw new Error('Voting period expired');
    }

    proposal.votes.set(voter, vote);
    this.updateProposalStatus(proposal);
    return true;
  }

  private updateProposalStatus(proposal: SchemaProposal) {
    const totalVotes = proposal.votes.size;
    const approveVotes = Array.from(proposal.votes.values()).filter(v => v === 'approve').length;
    const rejectVotes = totalVotes - approveVotes;

    const quorum = this.authorities.size * this.config.quorumRequirement;
    const approvalThreshold = totalVotes * this.config.approvalThreshold;

    if (totalVotes >= quorum) {
      if (approveVotes >= approvalThreshold) {
        proposal.status = 'approved';
      } else if (rejectVotes > totalVotes - approvalThreshold) {
        proposal.status = 'rejected';
      }
    }

    if (new Date() > proposal.expiresAt && proposal.status === 'pending') {
      proposal.status = 'expired';
    }
  }
}
```

### Authority Verification Process

```typescript
interface VerificationRequest {
  authority: string;
  documents: string[];
  submittedAt: Date;
  reviewedBy?: string;
  status: 'pending' | 'approved' | 'rejected';
  notes?: string;
}

class AuthorityVerification {
  private requests: Map<string, VerificationRequest> = new Map();
  private verifiers: Set<string> = new Set();

  submitVerificationRequest(
    authority: string,
    documents: string[]
  ): string {
    const requestId = `verification_${authority}_${Date.now()}`;
    
    this.requests.set(requestId, {
      authority,
      documents,
      submittedAt: new Date(),
      status: 'pending'
    });

    return requestId;
  }

  reviewVerificationRequest(
    requestId: string,
    reviewer: string,
    approved: boolean,
    notes?: string
  ): boolean {
    if (!this.verifiers.has(reviewer)) {
      throw new Error('Unauthorized reviewer');
    }

    const request = this.requests.get(requestId);
    if (!request) {
      throw new Error('Request not found');
    }

    request.reviewedBy = reviewer;
    request.status = approved ? 'approved' : 'rejected';
    request.notes = notes;

    return true;
  }

  addVerifier(address: string) {
    this.verifiers.add(address);
  }

  removeVerifier(address: string) {
    this.verifiers.delete(address);
  }
}
```

---

## Compliance and Auditing

### Audit Trail

```typescript
interface AuditEntry {
  timestamp: Date;
  authority: string;
  action: string;
  target: string;
  result: 'success' | 'failure';
  details: Record<string, any>;
  transactionHash?: string;
}

class AuditLogger {
  private entries: AuditEntry[] = [];

  logAction(
    authority: string,
    action: string,
    target: string,
    result: 'success' | 'failure',
    details: Record<string, any> = {},
    transactionHash?: string
  ) {
    this.entries.push({
      timestamp: new Date(),
      authority,
      action,
      target,
      result,
      details,
      transactionHash
    });
  }

  getAuditTrail(
    filters: {
      authority?: string;
      action?: string;
      startDate?: Date;
      endDate?: Date;
    } = {}
  ): AuditEntry[] {
    return this.entries.filter(entry => {
      if (filters.authority && entry.authority !== filters.authority) {
        return false;
      }
      if (filters.action && entry.action !== filters.action) {
        return false;
      }
      if (filters.startDate && entry.timestamp < filters.startDate) {
        return false;
      }
      if (filters.endDate && entry.timestamp > filters.endDate) {
        return false;
      }
      return true;
    });
  }

  exportAuditTrail(format: 'json' | 'csv' = 'json'): string {
    if (format === 'csv') {
      const headers = ['timestamp', 'authority', 'action', 'target', 'result', 'transactionHash'];
      const rows = this.entries.map(entry => [
        entry.timestamp.toISOString(),
        entry.authority,
        entry.action,
        entry.target,
        entry.result,
        entry.transactionHash || ''
      ]);
      
      return [headers, ...rows].map(row => row.join(',')).join('\n');
    }
    
    return JSON.stringify(this.entries, null, 2);
  }
}
```

### Compliance Monitoring

```typescript
interface ComplianceRule {
  name: string;
  condition: (entry: AuditEntry) => boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  action: 'log' | 'alert' | 'block';
}

class ComplianceMonitor {
  private rules: ComplianceRule[] = [];
  private violations: AuditEntry[] = [];

  addRule(rule: ComplianceRule) {
    this.rules.push(rule);
  }

  checkCompliance(entry: AuditEntry): boolean {
    let compliant = true;

    for (const rule of this.rules) {
      if (rule.condition(entry)) {
        compliant = false;
        this.violations.push(entry);

        switch (rule.action) {
          case 'log':
            console.log(`Compliance violation: ${rule.name}`, entry);
            break;
          case 'alert':
            this.sendAlert(rule, entry);
            break;
          case 'block':
            throw new Error(`Action blocked by compliance rule: ${rule.name}`);
        }
      }
    }

    return compliant;
  }

  private sendAlert(rule: ComplianceRule, entry: AuditEntry) {
    // Implementation would send alerts to monitoring system
    console.warn(`COMPLIANCE ALERT [${rule.severity.toUpperCase()}]: ${rule.name}`, {
      entry,
      rule: rule.name,
      severity: rule.severity
    });
  }

  getViolations(severity?: ComplianceRule['severity']): AuditEntry[] {
    if (!severity) {
      return this.violations;
    }

    return this.violations.filter(entry => {
      return this.rules.some(rule => 
        rule.condition(entry) && rule.severity === severity
      );
    });
  }
}

// Example compliance rules
const complianceRules: ComplianceRule[] = [
  {
    name: 'High Volume Authority',
    condition: (entry) => entry.action === 'create_attestation' && 
                          entry.details.volume > 1000,
    severity: 'medium',
    action: 'alert'
  },
  {
    name: 'Unverified Authority Schema Creation',
    condition: (entry) => entry.action === 'create_schema' && 
                          !entry.details.authorityVerified,
    severity: 'low',
    action: 'log'
  },
  {
    name: 'Failed Authentication Attempts',
    condition: (entry) => entry.result === 'failure' && 
                          entry.action.includes('auth'),
    severity: 'high',
    action: 'alert'
  }
];
```

---

## Administrative Best Practices

### Security Guidelines

| Practice | Description | Implementation |
|----------|-------------|----------------|
| **Multi-Signature Authority** | Use multiple keys for critical operations | Implement threshold signatures |
| **Role-Based Access** | Limit authority permissions by role | Use permission matrices |
| **Regular Audits** | Monitor all administrative actions | Implement comprehensive logging |
| **Key Rotation** | Regularly update signing keys | Automate key management |
| **Backup Procedures** | Maintain secure key backups | Use hardware security modules |

### Operational Procedures

**Authority Onboarding:**
1. Submit verification documents
2. Complete identity verification process  
3. Register authority on-chain
4. Configure monitoring and alerting
5. Establish backup procedures

**Schema Deployment:**
1. Design and validate schema structure
2. Submit governance proposal (if required)
3. Wait for approval/voting period
4. Deploy schema to testnet first
5. Deploy to mainnet after testing

**Incident Response:**
1. Identify and assess severity
2. Implement immediate containment
3. Notify relevant stakeholders
4. Investigate root cause
5. Implement preventive measures

### Monitoring Dashboards

```typescript
interface DashboardMetrics {
  totalAuthorities: number;
  verifiedAuthorities: number;
  activeSchemas: number;
  dailyAttestations: number;
  systemHealth: SystemHealth;
  recentViolations: number;
}

class AdminDashboard {
  async getDashboardMetrics(): Promise<DashboardMetrics> {
    // Implementation would gather metrics from various sources
    return {
      totalAuthorities: 150,
      verifiedAuthorities: 89,
      activeSchemas: 45,
      dailyAttestations: 1250,
      systemHealth: await new HealthMonitor().checkSystemHealth(sdk),
      recentViolations: 3
    };
  }
}
```

This administration framework provides the foundation for managing authorities, monitoring system health, implementing governance, and maintaining compliance across the AttestProtocol ecosystem.