---
title: 'Webhooks & Events'
description: 'Event handling patterns and webhook integration for real-time attestation updates'
icon: 'webhook'
---

## Overview

AttestProtocol provides comprehensive event monitoring through the **Horizon Indexer**, a specialized Express.js service that ingests and processes data from Stellar Horizon RPC endpoints. The system maintains a synchronized MongoDB database of contract-specific events and provides both REST APIs and webhook patterns for real-time notifications.

## Horizon Indexer Architecture

The Horizon Indexer serves as the backbone for event processing:

- **Real-time data ingestion** from Stellar Horizon RPC
- **MongoDB database integration** for reliable data persistence  
- **Contract-specific data indexing** and filtering
- **RESTful API endpoints** for client applications
- **Event monitoring and synchronization** across testnet and mainnet

---

## Horizon Indexer API

### Health Check Endpoint

Monitor the indexer's operational status:

```bash
GET /api/indexer/health
```

**Response:**
```json
{
  "status": "ok",
  "mongodb_status": "connected",
  "soroban_rpc_status": "healthy", 
  "network": "testnet",
  "indexing_contract": "CDDRYX6CX4DLYTKXJFHX5BPHSQUCIPUFTEN74XJNK5YFFENYUBKYCITO",
  "last_processed_ledger_in_db": 1021467,
  "db_connection_explicitly_attempted_in_health_check": false
}
```

### Event Ingestion Endpoint

Trigger manual event ingestion:

```bash
POST /api/indexer/events/ingest
Content-Type: application/json

{
  "startLedger": 1021467
}
```

**Response:**
```json
{
  "success": true,
  "message": "Event ingestion process initiated. Requested start ledger: 1021467. Check server logs for progress."
}
```

---

## Event Types

### Stellar Contract Events

Events are extracted from Soroban contract transactions and stored in MongoDB:

| Event | Description | Data Structure |
|-------|-------------|----------------|
| **AuthorityRegistered** | New authority registration | `authority_address`, `metadata`, `tx_hash` |
| **SchemaCreated** | New schema created | `schema_uid`, `authority`, `definition`, `revocable` |
| **AttestationCreated** | New attestation issued | `schema_uid`, `subject`, `attester`, `data`, `reference` |
| **AttestationRevoked** | Attestation revoked | `schema_uid`, `subject`, `attester`, `revocation_time` |

### Event Data Model

```typescript
interface StoredEvent {
  eventId: string;                    // Unique event identifier
  event: {                           // Raw event data from Stellar
    id: string;
    type: string;
    ledger: number;
    ledgerClosedAt: string;
    contractId: string;
    topics: string[];
    value: any;
    txHash: string;
  };
  transactionDetails: {              // Associated transaction data
    status: string;
    applicationOrder: number;
    feeBump: boolean;
    envelopeXdr: string;
    resultXdr: string;
    resultMetaXdr: string;
    ledger: number;
    createdAt: string;
  };
  ingestedAt: Date;                  // When stored in MongoDB
}
```

### Solana Events

Solana events are emitted by Anchor programs and available through transaction logs:

| Event | Description | Data |
|-------|-------------|------|
| **AuthorityInitialized** | Authority account created | `authority`, `deployer`, `timestamp` |
| **SchemaDeployed** | Schema PDA created | `schema`, `deployer`, `name`, `content` |
| **AttestationMade** | Attestation created | `attestation`, `attester`, `recipient`, `schema` |
| **AttestationRevoked** | Attestation revoked | `attestation`, `attester`, `revocation_time` |

---

## Event Monitoring

### Horizon Indexer Implementation

The production event monitoring system built into the Horizon indexer:

```typescript
import { rpc } from '@stellar/stellar-sdk';
import { MongoClient } from 'mongodb';

interface HorizonIndexerConfig {
  sorobanRpcUrl: string;
  mongoUri: string;
  contractId: string;
  maxEventsPerFetch: number;
  ledgerHistoryLimitDays: number;
}

class HorizonEventIndexer {
  private sorobanServer: rpc.Server;
  private db: any;
  private config: HorizonIndexerConfig;

  constructor(config: HorizonIndexerConfig) {
    this.config = config;
    this.sorobanServer = new rpc.Server(config.sorobanRpcUrl, {
      allowHttp: config.sorobanRpcUrl.startsWith('http://'),
    });
  }

  async fetchAndStoreEvents(startLedger?: number): Promise<{
    message: string;
    eventsFetched: number;
    processedUpToLedger: number;
    lastRpcLedger: number;
  }> {
    // Get latest ledger from RPC
    const latestLedgerData = await this.sorobanServer.getLatestLedger();
    const latestLedgerSequence = latestLedgerData.sequence;

    // Determine starting ledger
    const lastProcessedLedger = await this.getLastProcessedLedgerFromDB();
    let currentLedgerToQuery = startLedger || (lastProcessedLedger > 0 ? lastProcessedLedger + 1 : 0);

    if (currentLedgerToQuery === 0) {
      const maxLookBackLedgers = this.config.ledgerHistoryLimitDays * 24 * 60 * 10;
      currentLedgerToQuery = Math.max(1, latestLedgerSequence - maxLookBackLedgers);
    }

    let totalEventsFetched = 0;
    let processedItemsForStorage: any[] = [];
    let nextCursor: string | undefined = undefined;

    // Paginated event fetching
    do {
      const eventsRequestParams = {
        filters: [{ 
          type: 'contract', 
          contractIds: [this.config.contractId], 
          topics: [] 
        }],
        pagination: {
          limit: this.config.maxEventsPerFetch,
          ...(nextCursor ? { cursor: nextCursor } : { startLedger: currentLedgerToQuery })
        },
      };

      // Direct RPC call to getEvents
      const rpcResponse = await fetch(this.config.sorobanRpcUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: `getEvents-${Date.now()}`,
          method: "getEvents",
          params: eventsRequestParams,
        }),
      });

      const result = await rpcResponse.json();
      const eventsResponse = result.result;

      if (eventsResponse?.events?.length > 0) {
        totalEventsFetched += eventsResponse.events.length;

        // Fetch transaction details for each event
        for (const event of eventsResponse.events) {
          let transactionDetails = null;
          
          if (event.txHash) {
            const txResponse = await fetch(this.config.sorobanRpcUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: "2.0",
                id: `getTx-${event.txHash}`,
                method: "getTransaction",
                params: { hash: event.txHash },
              }),
            });
            
            const txResult = await txResponse.json();
            transactionDetails = txResult.result;
          }

          processedItemsForStorage.push({ 
            event, 
            transactionDetails, 
            eventId: event.id 
          });
        }
      }

      nextCursor = eventsResponse?.cursor;
    } while (nextCursor);

    // Store events in MongoDB
    if (processedItemsForStorage.length > 0) {
      await this.storeEventsInDB(processedItemsForStorage);
    }

    return {
      message: `Fetched ${totalEventsFetched} events`,
      eventsFetched: totalEventsFetched,
      processedUpToLedger: currentLedgerToQuery,
      lastRpcLedger: latestLedgerSequence,
    };
  }

  private async storeEventsInDB(eventsWithTransactions: any[]) {
    const operations = eventsWithTransactions.map((item) => ({
      updateOne: {
        filter: { eventId: item.event.id },
        update: { $set: { ...item, ingestedAt: new Date() } },
        upsert: true,
      },
    }));

    const collection = this.db.collection('contract_events_with_tx');
    await collection.bulkWrite(operations);
  }

  private async getLastProcessedLedgerFromDB(): Promise<number> {
    const metadata = await this.db
      .collection('metadata')
      .findOne({ key: 'lastProcessedLedgerMeta' });
    return metadata ? metadata.value : 0;
  }
}
```

### Solana Event Monitoring

```typescript
import { Connection, PublicKey } from '@solana/web3.js';
import * as anchor from '@coral-xyz/anchor';

class SolanaEventMonitor {
  private connection: Connection;
  private programId: PublicKey;
  private program: anchor.Program;

  constructor(rpcUrl: string, programId: string, idl: any) {
    this.connection = new Connection(rpcUrl);
    this.programId = new PublicKey(programId);
    
    const provider = new anchor.AnchorProvider(
      this.connection,
      {} as any, // No wallet needed for monitoring
      { commitment: 'confirmed' }
    );
    
    this.program = new anchor.Program(idl, this.programId, provider);
  }

  async startMonitoring(onEvent: (event: any) => void) {
    // Monitor program logs
    const logSubscription = this.connection.onLogs(
      this.programId,
      (logs, context) => {
        this.processLogs(logs, context, onEvent);
      },
      'confirmed'
    );

    return logSubscription;
  }

  private async processLogs(
    logs: any,
    context: any,
    onEvent: (event: any) => void
  ) {
    try {
      // Parse program logs for events
      const events = this.parseEventLogs(logs.logs);
      
      for (const event of events) {
        onEvent({
          type: event.name,
          data: event.data,
          transactionSignature: logs.signature,
          slot: context.slot,
          timestamp: new Date()
        });
      }
    } catch (error) {
      console.error('Error processing logs:', error);
    }
  }

  private parseEventLogs(logs: string[]): any[] {
    const events = [];
    
    for (const log of logs) {
      // Parse Anchor event logs
      if (log.includes('Program log:') && log.includes('EVENT:')) {
        try {
          const eventData = log.split('EVENT:')[1].trim();
          const parsed = JSON.parse(eventData);
          events.push(parsed);
        } catch (error) {
          // Skip invalid event logs
        }
      }
    }
    
    return events;
  }

  async getHistoricalEvents(
    fromSlot: number,
    toSlot: number
  ): Promise<any[]> {
    const signatures = await this.connection.getSignaturesForAddress(
      this.programId,
      {
        before: undefined,
        until: undefined,
        limit: 1000
      }
    );

    const events = [];
    
    for (const sig of signatures) {
      if (sig.slot >= fromSlot && sig.slot <= toSlot) {
        const transaction = await this.connection.getTransaction(
          sig.signature,
          { commitment: 'confirmed' }
        );
        
        if (transaction?.meta?.logMessages) {
          const transactionEvents = this.parseEventLogs(
            transaction.meta.logMessages
          );
          
          events.push(...transactionEvents.map(event => ({
            ...event,
            transactionSignature: sig.signature,
            slot: sig.slot,
            timestamp: new Date((sig.blockTime || 0) * 1000)
          })));
        }
      }
    }
    
    return events;
  }
}
```

---

---

## Integrating with Horizon Indexer

### MongoDB Event Querying

Query events directly from the Horizon indexer's MongoDB database:

```typescript
import { MongoClient } from 'mongodb';

class HorizonEventClient {
  private db: any;

  constructor(mongoUri: string) {
    const client = new MongoClient(mongoUri);
    this.db = client.db('horizon_indexer');
  }

  async getEvents(filters: {
    eventTypes?: string[];
    contractId?: string;
    fromLedger?: number;
    toLedger?: number;
    limit?: number;
  } = {}) {
    const collection = this.db.collection('contract_events_with_tx');
    
    const query: any = {};
    
    if (filters.eventTypes) {
      query['event.type'] = { $in: filters.eventTypes };
    }
    
    if (filters.contractId) {
      query['event.contractId'] = filters.contractId;
    }
    
    if (filters.fromLedger || filters.toLedger) {
      query['event.ledger'] = {};
      if (filters.fromLedger) query['event.ledger'].$gte = filters.fromLedger;
      if (filters.toLedger) query['event.ledger'].$lte = filters.toLedger;
    }

    return await collection
      .find(query)
      .sort({ 'event.ledger': -1 })
      .limit(filters.limit || 100)
      .toArray();
  }

  async getEventsByTxHash(txHash: string) {
    const collection = this.db.collection('contract_events_with_tx');
    return await collection.find({ 'event.txHash': txHash }).toArray();
  }

  async getLatestEvents(count: number = 10) {
    const collection = this.db.collection('contract_events_with_tx');
    return await collection
      .find({})
      .sort({ ingestedAt: -1 })
      .limit(count)
      .toArray();
  }

  async watchEvents(callback: (event: any) => void) {
    const collection = this.db.collection('contract_events_with_tx');
    
    // MongoDB Change Streams for real-time monitoring
    const changeStream = collection.watch([
      { $match: { operationType: 'insert' } }
    ]);

    changeStream.on('change', (change) => {
      if (change.operationType === 'insert') {
        callback(change.fullDocument);
      }
    });

    return changeStream;
  }
}
```

### Environment Configuration

Configure the Horizon indexer using environment variables:

```bash
# Horizon Indexer Configuration
MONGODB_URI=mongodb://localhost:27017/horizon_indexer
STELLAR_NETWORK=testnet

# Network-specific RPC URLs (automatically selected)
# Testnet: https://soroban-testnet.stellar.org
# Mainnet: https://soroban-rpc.stellar.org
```

---

## Webhook Implementation

### Horizon-Integrated Webhook Server

```typescript
import express from 'express';
import crypto from 'crypto';

interface WebhookPayload {
  eventType: string;
  eventId: string;
  timestamp: string;
  data: any;
  chain: 'stellar' | 'solana';
  signature?: string;
}

interface WebhookSubscription {
  id: string;
  url: string;
  events: string[];
  secret?: string;
  active: boolean;
  retryConfig: {
    maxRetries: number;
    backoffMs: number;
  };
}

class WebhookManager {
  private subscriptions: Map<string, WebhookSubscription> = new Map();
  private eventQueue: WebhookPayload[] = [];

  subscribe(subscription: Omit<WebhookSubscription, 'id'>): string {
    const id = crypto.randomUUID();
    this.subscriptions.set(id, { ...subscription, id });
    return id;
  }

  unsubscribe(id: string): boolean {
    return this.subscriptions.delete(id);
  }

  async processEvent(event: any, chain: 'stellar' | 'solana') {
    const payload: WebhookPayload = {
      eventType: event.type,
      eventId: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      data: event,
      chain
    };

    // Queue event for processing
    this.eventQueue.push(payload);
    
    // Process immediately (in production, use a job queue)
    await this.processEventQueue();
  }

  private async processEventQueue() {
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift()!;
      await this.deliverEvent(event);
    }
  }

  private async deliverEvent(payload: WebhookPayload) {
    for (const [id, subscription] of this.subscriptions) {
      if (!subscription.active) continue;
      
      if (!subscription.events.includes(payload.eventType)) continue;

      await this.deliverToSubscription(payload, subscription);
    }
  }

  private async deliverToSubscription(
    payload: WebhookPayload,
    subscription: WebhookSubscription
  ) {
    let attempts = 0;
    const maxRetries = subscription.retryConfig.maxRetries;

    while (attempts <= maxRetries) {
      try {
        const signedPayload = this.signPayload(payload, subscription.secret);
        
        const response = await fetch(subscription.url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Attest-Signature': signedPayload.signature || '',
            'X-Attest-Event-Type': payload.eventType,
            'X-Attest-Event-Id': payload.eventId
          },
          body: JSON.stringify(signedPayload)
        });

        if (response.ok) {
          console.log(`Webhook delivered to ${subscription.url}`);
          return;
        }

        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      } catch (error) {
        attempts++;
        console.error(
          `Webhook delivery failed (attempt ${attempts}/${maxRetries + 1}):`,
          error
        );

        if (attempts <= maxRetries) {
          const delay = subscription.retryConfig.backoffMs * Math.pow(2, attempts - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    console.error(`Failed to deliver webhook to ${subscription.url} after ${maxRetries + 1} attempts`);
  }

  private signPayload(
    payload: WebhookPayload,
    secret?: string
  ): WebhookPayload & { signature?: string } {
    if (!secret) {
      return payload;
    }

    const bodyString = JSON.stringify(payload);
    const signature = crypto
      .createHmac('sha256', secret)
      .update(bodyString)
      .digest('hex');

    return {
      ...payload,
      signature: `sha256=${signature}`
    };
  }
}
```

### Express Webhook Server

```typescript
const app = express();
const webhookManager = new WebhookManager();

app.use(express.json());

// Webhook subscription endpoint
app.post('/api/webhooks/subscribe', (req, res) => {
  const { url, events, secret } = req.body;

  if (!url || !events || !Array.isArray(events)) {
    return res.status(400).json({ error: 'Invalid subscription data' });
  }

  const subscriptionId = webhookManager.subscribe({
    url,
    events,
    secret,
    active: true,
    retryConfig: {
      maxRetries: 3,
      backoffMs: 1000
    }
  });

  res.json({ subscriptionId });
});

// Webhook unsubscribe endpoint
app.delete('/api/webhooks/subscribe/:id', (req, res) => {
  const { id } = req.params;
  const success = webhookManager.unsubscribe(id);
  
  if (success) {
    res.json({ message: 'Unsubscribed successfully' });
  } else {
    res.status(404).json({ error: 'Subscription not found' });
  }
});

// Health check endpoint for webhook receivers
app.get('/api/webhooks/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

---

## Event Processing Patterns

### Event Aggregation

```typescript
interface EventAggregate {
  authority: string;
  totalSchemas: number;
  totalAttestations: number;
  lastActivity: Date;
  verificationStatus: boolean;
}

class EventAggregator {
  private aggregates: Map<string, EventAggregate> = new Map();

  processEvent(event: any) {
    switch (event.type) {
      case 'AuthorityRegistered':
      case 'AuthorityInitialized':
        this.handleAuthorityEvent(event);
        break;
      
      case 'SchemaCreated':
      case 'SchemaDeployed':
        this.handleSchemaEvent(event);
        break;
      
      case 'AttestationCreated':
      case 'AttestationMade':
        this.handleAttestationEvent(event);
        break;
    }
  }

  private handleAuthorityEvent(event: any) {
    const authority = event.data.authority || event.data.authority_address;
    
    if (!this.aggregates.has(authority)) {
      this.aggregates.set(authority, {
        authority,
        totalSchemas: 0,
        totalAttestations: 0,
        lastActivity: new Date(event.timestamp),
        verificationStatus: false
      });
    }

    const aggregate = this.aggregates.get(authority)!;
    aggregate.lastActivity = new Date(event.timestamp);
  }

  private handleSchemaEvent(event: any) {
    const authority = event.data.authority || event.data.deployer;
    const aggregate = this.aggregates.get(authority);
    
    if (aggregate) {
      aggregate.totalSchemas++;
      aggregate.lastActivity = new Date(event.timestamp);
    }
  }

  private handleAttestationEvent(event: any) {
    const authority = event.data.attester;
    const aggregate = this.aggregates.get(authority);
    
    if (aggregate) {
      aggregate.totalAttestations++;
      aggregate.lastActivity = new Date(event.timestamp);
    }
  }

  getAggregate(authority: string): EventAggregate | undefined {
    return this.aggregates.get(authority);
  }

  getAllAggregates(): EventAggregate[] {
    return Array.from(this.aggregates.values());
  }
}
```

### Real-time Notifications

```typescript
import { Server as SocketIOServer } from 'socket.io';
import { createServer } from 'http';

class RealTimeNotifier {
  private io: SocketIOServer;
  private subscriptions: Map<string, Set<string>> = new Map();

  constructor(port: number = 3001) {
    const server = createServer();
    this.io = new SocketIOServer(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });

    this.setupSocketHandlers();
    server.listen(port, () => {
      console.log(`Real-time notification server running on port ${port}`);
    });
  }

  private setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log('Client connected:', socket.id);

      socket.on('subscribe', (data: { events: string[] }) => {
        for (const eventType of data.events) {
          if (!this.subscriptions.has(eventType)) {
            this.subscriptions.set(eventType, new Set());
          }
          this.subscriptions.get(eventType)!.add(socket.id);
        }
        
        socket.emit('subscribed', { events: data.events });
      });

      socket.on('unsubscribe', (data: { events: string[] }) => {
        for (const eventType of data.events) {
          this.subscriptions.get(eventType)?.delete(socket.id);
        }
        
        socket.emit('unsubscribed', { events: data.events });
      });

      socket.on('disconnect', () => {
        // Clean up subscriptions
        for (const subscribers of this.subscriptions.values()) {
          subscribers.delete(socket.id);
        }
        console.log('Client disconnected:', socket.id);
      });
    });
  }

  notifyEvent(event: any) {
    const subscribers = this.subscriptions.get(event.type);
    
    if (subscribers) {
      for (const socketId of subscribers) {
        this.io.to(socketId).emit('event', event);
      }
    }

    // Also emit to all clients subscribed to 'all' events
    const allSubscribers = this.subscriptions.get('all');
    if (allSubscribers) {
      for (const socketId of allSubscribers) {
        this.io.to(socketId).emit('event', event);
      }
    }
  }
}
```

---

## Integration Examples

### Database Event Storage

```typescript
import { Pool } from 'pg';

interface StoredEvent {
  id: string;
  eventType: string;
  chain: string;
  data: any;
  transactionHash: string;
  blockNumber: number;
  timestamp: Date;
  processed: boolean;
}

class EventStorage {
  private pool: Pool;

  constructor(connectionString: string) {
    this.pool = new Pool({ connectionString });
    this.initializeSchema();
  }

  private async initializeSchema() {
    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS events (
        id VARCHAR PRIMARY KEY,
        event_type VARCHAR NOT NULL,
        chain VARCHAR NOT NULL,
        data JSONB NOT NULL,
        transaction_hash VARCHAR,
        block_number BIGINT,
        timestamp TIMESTAMP NOT NULL,
        processed BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW()
      );
      
      CREATE INDEX IF NOT EXISTS idx_events_type ON events(event_type);
      CREATE INDEX IF NOT EXISTS idx_events_chain ON events(chain);
      CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);
      CREATE INDEX IF NOT EXISTS idx_events_processed ON events(processed);
    `);
  }

  async storeEvent(event: Omit<StoredEvent, 'id' | 'processed'>): Promise<string> {
    const id = crypto.randomUUID();
    
    await this.pool.query(`
      INSERT INTO events (id, event_type, chain, data, transaction_hash, block_number, timestamp)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, [
      id,
      event.eventType,
      event.chain,
      JSON.stringify(event.data),
      event.transactionHash,
      event.blockNumber,
      event.timestamp
    ]);

    return id;
  }

  async getEvents(filters: {
    eventType?: string;
    chain?: string;
    startTime?: Date;
    endTime?: Date;
    processed?: boolean;
    limit?: number;
  } = {}): Promise<StoredEvent[]> {
    let query = 'SELECT * FROM events WHERE 1=1';
    const params: any[] = [];
    let paramCount = 0;

    if (filters.eventType) {
      query += ` AND event_type = $${++paramCount}`;
      params.push(filters.eventType);
    }

    if (filters.chain) {
      query += ` AND chain = $${++paramCount}`;
      params.push(filters.chain);
    }

    if (filters.startTime) {
      query += ` AND timestamp >= $${++paramCount}`;
      params.push(filters.startTime);
    }

    if (filters.endTime) {
      query += ` AND timestamp <= $${++paramCount}`;
      params.push(filters.endTime);
    }

    if (filters.processed !== undefined) {
      query += ` AND processed = $${++paramCount}`;
      params.push(filters.processed);
    }

    query += ' ORDER BY timestamp DESC';

    if (filters.limit) {
      query += ` LIMIT $${++paramCount}`;
      params.push(filters.limit);
    }

    const result = await this.pool.query(query, params);
    
    return result.rows.map(row => ({
      id: row.id,
      eventType: row.event_type,
      chain: row.chain,
      data: row.data,
      transactionHash: row.transaction_hash,
      blockNumber: row.block_number,
      timestamp: row.timestamp,
      processed: row.processed
    }));
  }

  async markProcessed(eventId: string): Promise<void> {
    await this.pool.query(
      'UPDATE events SET processed = TRUE WHERE id = $1',
      [eventId]
    );
  }
}
```

### Complete Event System

```typescript
class AttestEventSystem {
  private stellarMonitor: StellarEventMonitor;
  private solanaMonitor: SolanaEventMonitor;
  private webhookManager: WebhookManager;
  private realTimeNotifier: RealTimeNotifier;
  private eventStorage: EventStorage;
  private eventAggregator: EventAggregator;

  constructor(config: {
    stellarRpc: string;
    stellarContractId: string;
    solanaRpc: string;
    solanaProgramId: string;
    solanaIdl: any;
    databaseUrl: string;
  }) {
    this.stellarMonitor = new StellarEventMonitor(
      config.stellarRpc,
      config.stellarContractId
    );
    
    this.solanaMonitor = new SolanaEventMonitor(
      config.solanaRpc,
      config.solanaProgramId,
      config.solanaIdl
    );
    
    this.webhookManager = new WebhookManager();
    this.realTimeNotifier = new RealTimeNotifier();
    this.eventStorage = new EventStorage(config.databaseUrl);
    this.eventAggregator = new EventAggregator();
  }

  async start() {
    // Start monitoring both chains
    await this.stellarMonitor.startMonitoring((event) => {
      this.handleEvent(event, 'stellar');
    });

    await this.solanaMonitor.startMonitoring((event) => {
      this.handleEvent(event, 'solana');
    });

    console.log('AttestEventSystem started successfully');
  }

  private async handleEvent(event: any, chain: 'stellar' | 'solana') {
    try {
      // Store event
      await this.eventStorage.storeEvent({
        eventType: event.type,
        chain,
        data: event.data,
        transactionHash: event.transactionHash || event.transactionSignature,
        blockNumber: event.ledger || event.slot,
        timestamp: event.timestamp
      });

      // Process aggregates
      this.eventAggregator.processEvent(event);

      // Send webhooks
      await this.webhookManager.processEvent(event, chain);

      // Send real-time notifications
      this.realTimeNotifier.notifyEvent(event);

      console.log(`Processed ${event.type} event from ${chain}`);
    } catch (error) {
      console.error('Error handling event:', error);
    }
  }

  // Public API methods
  subscribeWebhook(subscription: any): string {
    return this.webhookManager.subscribe(subscription);
  }

  unsubscribeWebhook(id: string): boolean {
    return this.webhookManager.unsubscribe(id);
  }

  async getEvents(filters: any): Promise<any[]> {
    return this.eventStorage.getEvents(filters);
  }

  getAuthorityStats(authority: string): any {
    return this.eventAggregator.getAggregate(authority);
  }
}
```

This comprehensive event system provides real-time monitoring, webhook delivery, data storage, and analytics for AttestProtocol operations across all supported blockchains.