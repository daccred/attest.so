---
title: 'Examples'
description: 'Production-ready code examples for Stellar and Solana implementations'
icon: 'code-branch'
---

## Complete Workflow

<Info>
These examples demonstrate end-to-end workflows for both Stellar and Solana. Each example includes error handling and best practices.
</Info>

### Platform Examples

<Tabs>
  <Tab title="Stellar">
    ```typescript
    import { AttestSDK, StellarConfig } from '@attestprotocol/sdk';

async function stellarWorkflow() {
  const config: StellarConfig = {
    secretKeyOrCustomSigner: process.env.STELLAR_SECRET_KEY!,
    publicKey: process.env.STELLAR_PUBLIC_KEY!,
    url: 'https://soroban-testnet.stellar.org'
  };
  
  const sdk = await AttestSDK.initializeStellar(config);

  // Register as authority
  const authResult = await sdk.registerAuthority();
  if (authResult.error) return authResult.error;

  // Create schema
  const schemaResult = await sdk.createSchema({
    schemaName: 'kyc-verification-v1',
    schemaContent: 'verified:bool,level:string,score:uint8,timestamp:uint64',
    revocable: true
  });
  if (schemaResult.error) return schemaResult.error;
  
  const schemaUID = schemaResult.data!.schemaUID;
  
  // Wait for indexing
  await new Promise(resolve => setTimeout(resolve, 10000));

  // Create attestation
  const attestResult = await sdk.attest({
    schemaUID: schemaUID,
    subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    value: 'verified:true,level:enhanced,score:95,timestamp:1704067200',
    reference: 'kyc-check-2024-001'
  });
  if (attestResult.error) return attestResult.error;

  // Fetch attestation
  const fetchResult = await sdk.fetchAttestation({
    schemaUID: schemaUID,
    subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    reference: 'kyc-check-2024-001'
  });
  
      return fetchResult.data;
    }
    ```
  </Tab>
  <Tab title="Solana">
    ```typescript
    import { AttestSDK, SolanaConfig } from '@attestprotocol/sdk';
import * as anchor from '@coral-xyz/anchor';

async function solanaWorkflow() {
  const config: SolanaConfig = {
    walletOrSecretKey: JSON.parse(process.env.SOLANA_SECRET_KEY!),
    url: 'https://api.devnet.solana.com'
  };
  
  const sdk = await AttestSDK.initializeSolana(config);

  // Check balance
  const balanceResult = await sdk.getWalletBalance();
  if (balanceResult.error) return balanceResult.error;
  
  if (balanceResult.data!.balance < 100000000) { // 0.1 SOL
    throw new Error('Insufficient SOL balance');
  }

  // Register as authority
  const authResult = await sdk.registerAuthority();
  if (authResult.error) return authResult.error;

  // Create schema
  const schemaResult = await sdk.createSchema({
    schemaName: 'reputation-score-v1',
    schemaContent: 'score:u8,category:string,verified_at:u64',
    revocable: true,
    levy: {
      amount: new anchor.BN(1000000),
      asset: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112'),
      recipient: balanceResult.data!.address
    }
  });
  if (schemaResult.error) return schemaResult.error;
  
  const schemaPDA = schemaResult.data!;

  // Create attestation
  const attestResult = await sdk.attest({
    schemaData: schemaPDA,
    data: 'score:85,category:defi,verified_at:1704067200',
    expirationTime: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60),
    revocable: true,
    accounts: {
      recipient: new anchor.web3.PublicKey('11111111111111111111111111111111'),
      levyReceipent: balanceResult.data!.address,
      mintAccount: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112')
    }
  });
  if (attestResult.error) return attestResult.error;

  // Fetch attestation
  const fetchResult = await sdk.fetchAttestation(attestResult.data!);
  
      return fetchResult.data;
    }
    ```
  </Tab>
</Tabs>

<Note>
Both examples follow the same workflow: initialize SDK → register authority → create schema → create attestation → fetch attestation.
</Note>

---

## Express.js API Integration

<Warning>
Always validate input data and implement proper authentication before production deployment.
</Warning>

<CodeGroup>
```typescript Full API Server
import express from 'express';
import { AttestSDK, StellarConfig, SolanaConfig } from '@attestprotocol/sdk';

const app = express();
app.use(express.json());

let stellarSDK: any;
let solanaSDK: any;

async function initializeSDKs() {
  stellarSDK = await AttestSDK.initializeStellar({
    secretKeyOrCustomSigner: process.env.STELLAR_SECRET_KEY!,
    publicKey: process.env.STELLAR_PUBLIC_KEY!
  });

  solanaSDK = await AttestSDK.initializeSolana({
    walletOrSecretKey: JSON.parse(process.env.SOLANA_SECRET_KEY!)
  });
}

app.post('/api/attest', async (req, res) => {
  const { chain, schemaUID, subject, data, reference } = req.body;

  try {
    let result;
    if (chain === 'stellar') {
      result = await stellarSDK.attest({
        schemaUID,
        subject,
        value: data,
        reference
      });
    } else if (chain === 'solana') {
      const balanceResult = await solanaSDK.getWalletBalance();
      result = await solanaSDK.attest({
        schemaData: new anchor.web3.PublicKey(schemaUID),
        data,
        accounts: {
          recipient: new anchor.web3.PublicKey(subject),
          levyReceipent: balanceResult.data!.address,
          mintAccount: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112')
        }
      });
    } else {
      return res.status(400).json({ error: 'Unsupported chain' });
    }

    if (result.error) {
      return res.status(500).json({ error: result.error });
    }

    res.json({ 
      success: true, 
      attestationId: result.data,
      chain 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/verify/:chain/:schema/:subject', async (req, res) => {
  const { chain, schema, subject } = req.params;

  try {
    let result;
    if (chain === 'stellar') {
      result = await stellarSDK.fetchAttestation({
        schemaUID: schema,
        subject: subject
      });
    } else if (chain === 'solana') {
      result = await solanaSDK.fetchAttestation(subject);
    } else {
      return res.status(400).json({ error: 'Unsupported chain' });
    }

    if (result.error) {
      return res.status(500).json({ error: result.error });
    }

    res.json({
      verified: !!result.data && !result.data.revoked,
      attestation: result.data,
      chain
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

initializeSDKs().then(() => {
  app.listen(3000);
});
```

```typescript Middleware Pattern
import { Request, Response, NextFunction } from 'express';

const attestMiddleware = (sdk: any) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      req.attestSDK = sdk;
      next();
    } catch (error) {
      res.status(500).json({ error: 'SDK initialization failed' });
    }
  };
};

// Usage
app.use('/api/stellar', attestMiddleware(stellarSDK));
app.use('/api/solana', attestMiddleware(solanaSDK));
```
</CodeGroup>

---

## Batch Operations

<Info>
Batch operations enable efficient processing of multiple attestations. Use Promise.all() for parallel execution.
</Info>

### Multiple Attestations

```typescript
async function batchAttestations() {
  const sdk = await AttestSDK.initializeSolana({
    walletOrSecretKey: JSON.parse(process.env.SOLANA_SECRET_KEY!)
  });

  await sdk.registerAuthority();

  const schemaResult = await sdk.createSchema({
    schemaName: 'user-verification-batch',
    schemaContent: 'verified:bool,tier:string,score:u8',
    revocable: true
  });

  if (schemaResult.error) throw schemaResult.error;

  const schemaPDA = schemaResult.data!;
  const walletBalance = await sdk.getWalletBalance();
  
  const users = [
    { address: '11111111111111111111111111111111', data: 'verified:true,tier:gold,score:95' },
    { address: '22222222222222222222222222222222', data: 'verified:true,tier:silver,score:80' },
    { address: '33333333333333333333333333333333', data: 'verified:true,tier:bronze,score:65' }
  ];

  const attestationPromises = users.map(user => sdk.attest({
    schemaData: schemaPDA,
    data: user.data,
    accounts: {
      recipient: new anchor.web3.PublicKey(user.address),
      levyReceipent: walletBalance.data!.address,
      mintAccount: new anchor.web3.PublicKey('So11111111111111111111111111111111111111112')
    }
  }));

  const results = await Promise.all(attestationPromises);
  
  return results.filter(result => !result.error).map(result => result.data);
}
```

<Note>
When performing batch operations, consider rate limits and transaction costs. Implement retry logic for failed attestations.
</Note>

---

## React Component

<Warning>
Never expose private keys in client-side code. Use server-side APIs or wallet integrations for production.
</Warning>

<CodeGroup>
```typescript React Hook
import React, { useState, useEffect } from 'react';
import { AttestSDK } from '@attestprotocol/sdk';

interface AttestationFormProps {
  chain: 'stellar' | 'solana';
}

// Custom hook for AttestSDK
export function useAttestSDK(chain: 'stellar' | 'solana') {
  const [sdk, setSdk] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function init() {
      try {
        let instance;
        if (chain === 'stellar') {
          instance = await AttestSDK.initializeStellar(stellarConfig);
        } else {
          instance = await AttestSDK.initializeSolana(solanaConfig);
        }
        setSdk(instance);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    init();
  }, [chain]);

  return { sdk, loading, error };
}
```

```typescript Component
export const AttestationForm: React.FC<AttestationFormProps> = ({ chain }) => {
  const [sdk, setSdk] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<string>('');

  useEffect(() => {
    async function initSDK() {
      try {
        let sdkInstance;
        if (chain === 'stellar') {
          sdkInstance = await AttestSDK.initializeStellar({
            secretKeyOrCustomSigner: process.env.REACT_APP_STELLAR_SECRET_KEY!,
            publicKey: process.env.REACT_APP_STELLAR_PUBLIC_KEY!
          });
        } else {
          sdkInstance = await AttestSDK.initializeSolana({
            walletOrSecretKey: JSON.parse(process.env.REACT_APP_SOLANA_SECRET_KEY!)
          });
        }
        setSdk(sdkInstance);
      } catch (error) {
        setResult(`SDK initialization failed: ${error.message}`);
      }
    }

    initSDK();
  }, [chain]);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!sdk) return;

    setLoading(true);
    const formData = new FormData(event.currentTarget);
    
    try {
      let attestResult;
      if (chain === 'stellar') {
        attestResult = await sdk.attest({
          schemaUID: formData.get('schemaUID') as string,
          subject: formData.get('subject') as string,
          value: formData.get('data') as string,
          reference: formData.get('reference') as string
        });
      } else {
        setResult('Solana attestation requires proper account setup');
        return;
      }

      if (attestResult.error) {
        setResult(`Error: ${attestResult.error}`);
      } else {
        setResult(`Success! Transaction: ${attestResult.data}`);
      }
    } catch (error) {
      setResult(`Error: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  if (!sdk) {
    return <div>Initializing {chain} SDK...</div>;
  }

  return (
    <div>
      <h2>Create {chain.charAt(0).toUpperCase() + chain.slice(1)} Attestation</h2>
      <form onSubmit={handleSubmit}>
        <input name="schemaUID" required placeholder="Schema UID" />
        <input name="subject" required placeholder="Subject address" />
        <textarea name="data" required placeholder="Attestation data" />
        <input name="reference" placeholder="Reference" />
        <button type="submit" disabled={loading}>
          {loading ? 'Creating...' : 'Create Attestation'}
        </button>
      </form>
      {result && <pre>{result}</pre>}
    </div>
  );
};
```
</CodeGroup>

---

## Error Handling

<Note>
Proper error handling is crucial for production applications. The examples below show comprehensive error management strategies.
</Note>

### Comprehensive Error Handler

<Tabs>
  <Tab title="Error Handler Class">
    ```typescript
    class AttestSDKErrorHandler {
  handleStellarError(error: any): string {
    if (error.status === 404) {
      return "Account not found. Fund your Stellar account.";
    }
    
    if (error.message?.includes('insufficient balance')) {
      return "Insufficient XLM balance.";
    }
    
    if (error.message?.includes('Invalid schema UID')) {
      return "Schema UID must be 64-character hex string.";
    }
    
    return `Stellar error: ${error.message || 'Unknown error'}`;
  }

  handleSolanaError(error: any): string {
    if (error.code === 6010) {
      return "Schema with this name already exists.";
    }
    
    if (error.code === 6002) {
      return "Attestation is already revoked.";
    }
    
    if (error.message?.includes('Insufficient funds')) {
      return "Insufficient SOL balance.";
    }
    
    return `Solana error: ${error.message || 'Unknown error'}`;
  }
}

async function robustOperation() {
  const errorHandler = new AttestSDKErrorHandler();
  const stellarSDK = await AttestSDK.initializeStellar(config);

  const result = await stellarSDK.attest({
    schemaUID: 'abc123...',
    subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    value: 'verified:true',
    reference: 'test-001'
  });

  if (result.error) {
    const errorMsg = errorHandler.handleStellarError(result.error);
    throw new Error(errorMsg);
  }

      return result.data;
    }
    ```
  </Tab>
  <Tab title="Error Constants">
    ```typescript
    const ERROR_CODES = {
      STELLAR: {
        INSUFFICIENT_BALANCE: 'insufficient balance',
        INVALID_SCHEMA: 'Invalid schema UID',
        ACCOUNT_NOT_FOUND: 404
      },
      SOLANA: {
        SCHEMA_EXISTS: 6010,
        ALREADY_REVOKED: 6002,
        INSUFFICIENT_FUNDS: 'Insufficient funds'
      }
    };

    function getErrorMessage(error: any, chain: 'stellar' | 'solana'): string {
      const codes = chain === 'stellar' ? ERROR_CODES.STELLAR : ERROR_CODES.SOLANA;
      
      for (const [key, value] of Object.entries(codes)) {
        if (error.code === value || error.message?.includes(value)) {
          return key.replace(/_/g, ' ').toLowerCase();
        }
      }
      
      return 'Unknown error occurred';
    }
    ```
  </Tab>
</Tabs>

---

## Environment Configuration

<Info>
Use environment variables to manage configuration across different environments (development, staging, production).
</Info>

### Configuration Utility

<CodeGroup>
```typescript Config Manager
interface EnvironmentConfig {
  stellar: StellarConfig;
  solana: SolanaConfig;
}

function getConfig(): EnvironmentConfig {
  const requiredEnvVars = [
    'STELLAR_SECRET_KEY',
    'STELLAR_PUBLIC_KEY', 
    'SOLANA_SECRET_KEY'
  ];

  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }

  return {
    stellar: {
      secretKeyOrCustomSigner: process.env.STELLAR_SECRET_KEY!,
      publicKey: process.env.STELLAR_PUBLIC_KEY!,
      url: process.env.STELLAR_RPC_URL || 'https://soroban-testnet.stellar.org'
    },
    solana: {
      walletOrSecretKey: JSON.parse(process.env.SOLANA_SECRET_KEY!),
      url: process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com',
      programId: process.env.SOLANA_PROGRAM_ID
    }
  };
}

// Usage
const config = getConfig();
const stellarSDK = await AttestSDK.initializeStellar(config.stellar);
const solanaSDK = await AttestSDK.initializeSolana(config.solana);
```

```typescript .env.example
# Stellar Configuration
STELLAR_SECRET_KEY=SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
STELLAR_PUBLIC_KEY=GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
STELLAR_RPC_URL=https://soroban-testnet.stellar.org

# Solana Configuration
SOLANA_SECRET_KEY=[1,2,3,...]
SOLANA_RPC_URL=https://api.devnet.solana.com
SOLANA_PROGRAM_ID=BMr9aui54YuxtpBzWXiFNmnr2iH6etRu7rMFJnKxjtpY

# Environment
NODE_ENV=development
```
</CodeGroup>

---

## Testing

<Warning>
Always use testnet/devnet for testing. Never run tests against mainnet to avoid unnecessary costs.
</Warning>

### Jest Integration Tests

<Tabs>
  <Tab title="Jest Tests">
    ```typescript
    describe('AttestSDK Integration Tests', () => {
  let stellarSDK: any;
  let testSchemaUID: string;

  beforeAll(async () => {
    stellarSDK = await AttestSDK.initializeStellar({
      secretKeyOrCustomSigner: process.env.TEST_STELLAR_SECRET_KEY!,
      publicKey: process.env.TEST_STELLAR_PUBLIC_KEY!
    });

    const authResult = await stellarSDK.registerAuthority();
    expect(authResult.error).toBeUndefined();
  });

  test('should create schema successfully', async () => {
    const result = await stellarSDK.createSchema({
      schemaName: 'test-schema-jest',
      schemaContent: 'test:bool,value:uint8',
      revocable: true
    });

    expect(result.error).toBeUndefined();
    expect(result.data).toBeDefined();
    expect(result.data.schemaUID).toMatch(/^[a-f0-9]{64}$/);
    
    testSchemaUID = result.data.schemaUID;
  });

  test('should create attestation successfully', async () => {
    const result = await stellarSDK.attest({
      schemaUID: testSchemaUID,
      subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
      value: 'test:true,value:42',
      reference: 'jest-test-001'
    });

    expect(result.error).toBeUndefined();
    expect(result.data).toBeDefined();
    expect(typeof result.data).toBe('string');
  });

  test('should handle invalid schema UID', async () => {
    const result = await stellarSDK.fetchSchema('invalid-uid');

    expect(result.error).toBeDefined();
    expect(result.data).toBeUndefined();
    });
    });
    ```
  </Tab>
  <Tab title="Test Utilities">
    ```typescript
    // test-utils.ts
    import { AttestSDK } from '@attestprotocol/sdk';

    export async function createTestSDK(chain: 'stellar' | 'solana') {
      if (chain === 'stellar') {
        return AttestSDK.initializeStellar({
          secretKeyOrCustomSigner: process.env.TEST_STELLAR_SECRET_KEY!,
          publicKey: process.env.TEST_STELLAR_PUBLIC_KEY!,
          url: 'https://soroban-testnet.stellar.org'
        });
      } else {
        return AttestSDK.initializeSolana({
          walletOrSecretKey: JSON.parse(process.env.TEST_SOLANA_SECRET_KEY!),
          url: 'https://api.devnet.solana.com'
        });
      }
    }

    export function generateTestData() {
      return {
        schemaName: `test-schema-${Date.now()}`,
        subject: 'GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
        value: 'test:true,score:100',
        reference: `test-ref-${Date.now()}`
      };
    }
    ```
  </Tab>
</Tabs>

---

## Production Patterns

<Info>
These patterns help build robust, scalable applications with AttestProtocol.
</Info>

### Retry Logic

<CodeGroup>
```typescript Exponential Backoff
async function withRetry<T>(
  operation: () => Promise<AttestSDKResponse<T>>,
  maxRetries: number = 3
): Promise<AttestSDKResponse<T>> {
  let lastError: any;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const result = await operation();
    
    if (!result.error) {
      return result;
    }
    
    lastError = result.error;
    
    const errorStr = result.error.toString().toLowerCase();
    if (errorStr.includes('unauthorized') || 
        errorStr.includes('invalid') ||
        errorStr.includes('already exists')) {
      break;
    }
    
    if (attempt < maxRetries) {
      const delay = 1000 * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  return { error: lastError };
}

// Usage
const result = await withRetry(
  () => sdk.attest(attestConfig),
  3 // max retries
);
```

```typescript Circuit Breaker
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  constructor(
    private threshold = 5,
    private timeout = 60000 // 1 minute
  ) {}

  async execute<T>(
    operation: () => Promise<T>
  ): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  private onFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}
```
</CodeGroup>

### Connection Pool

<Note>
Connection pooling improves performance for high-throughput applications by reusing SDK instances.
</Note>

```typescript
class SDKConnectionPool {
  private stellarInstances: StellarAttestSDK[] = [];
  private solanaInstances: SolanaAttestSDK[] = [];
  private currentStellar = 0;
  private currentSolana = 0;

  async initialize(poolSize: number = 3) {
    const stellarPromises = Array(poolSize).fill(null).map(() =>
      AttestSDK.initializeStellar({
        secretKeyOrCustomSigner: process.env.STELLAR_SECRET_KEY!,
        publicKey: process.env.STELLAR_PUBLIC_KEY!
      })
    );

    const solanaPromises = Array(poolSize).fill(null).map(() =>
      AttestSDK.initializeSolana({
        walletOrSecretKey: JSON.parse(process.env.SOLANA_SECRET_KEY!)
      })
    );

    this.stellarInstances = await Promise.all(stellarPromises);
    this.solanaInstances = await Promise.all(solanaPromises);
  }

  getStellarSDK(): StellarAttestSDK {
    const sdk = this.stellarInstances[this.currentStellar];
    this.currentStellar = (this.currentStellar + 1) % this.stellarInstances.length;
    return sdk;
  }

  getSolanaSDK(): SolanaAttestSDK {
    const sdk = this.solanaInstances[this.currentSolana];  
    this.currentSolana = (this.currentSolana + 1) % this.solanaInstances.length;
    return sdk;
  }
}

// Usage
const pool = new SDKConnectionPool();
await pool.initialize(5); // 5 instances per chain

// Use in request handler
app.get('/api/attest', async (req, res) => {
  const sdk = req.query.chain === 'stellar' 
    ? pool.getStellarSDK() 
    : pool.getSolanaSDK();
  
  // Process request with SDK instance
});
```

---

## Additional Resources

<CardGroup cols={2}>
  <Card title="SDK Methods" icon="code" href="/sdks/typescript/methods">
    Complete API reference
  </Card>
  <Card title="Error Reference" icon="triangle-exclamation" href="/reference/errors">
    Error codes and solutions
  </Card>
  <Card title="Best Practices" icon="shield-check" href="/guides/best-practices">
    Security and optimization tips
  </Card>
  <Card title="GitHub Examples" icon="github" href="https://github.com/attestprotocol/examples">
    More code samples on GitHub
  </Card>
</CardGroup>
```