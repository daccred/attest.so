---
title: 'DAO Voting Integration'
description: 'Implement participation verification and weighted voting using attestations'
---

Prove participation and eligibility in DAO governance processes using AttestProtocol. This guide covers membership verification, reputation-based voting, and contribution tracking.

---

## Use Case Overview

DAO voting attestations enable sophisticated governance models beyond simple token-weighted voting. Track contributions, verify membership, and implement reputation-based voting power.

**Ideal For:**
- DAOs requiring Sybil-resistant voting
- Contribution-based governance models
- Multi-tier membership systems
- Cross-DAO reputation portability

---

## Implementation

### Schema Selection

Choose or create schemas for your governance needs:

```typescript
// Basic DAO membership
const membershipSchema = 'dao-member-v1';
// Definition: isMember:bool,joinDate:uint64,role:string,votingPower:uint32

// Contribution tracking
const contributionSchema = 'dao-contribution-v1';
// Definition: totalContributions:uint32,codeCommits:uint16,proposalsSubmitted:uint16,lastActive:uint64

// Reputation scoring
const reputationSchema = 'dao-reputation-v1';
// Definition: score:uint16,participationRate:uint8,proposalSuccess:uint8,peerEndorsements:uint16
```

### DAO Integration

Implement attestation-based governance:

```typescript
class AttestationDAO {
  private sdk: AttestSDKBase;
  private daoAddress: string;
  
  async grantMembership(memberAddress: string, role: string = 'member') {
    // Verify membership proposal passed
    const proposal = await this.getProposal(memberAddress);
    
    if (!proposal.passed) {
      throw new Error('Membership proposal not passed');
    }
    
    // Issue membership attestation
    const attestation = await this.sdk.attest({
      schemaUID: 'dao-member-v1',
      subject: memberAddress,
      value: `isMember:true,joinDate:${Date.now()},role:${role},votingPower:1`,
      reference: `membership-${proposal.id}`
    });
    
    return attestation;
  }
  
  async calculateVotingPower(voterAddress: string): Promise<number> {
    let totalPower = 0;
    
    // 1. Check basic membership
    const membership = await this.sdk.fetchAttestation({
      schemaUID: 'dao-member-v1',
      subject: voterAddress
    });
    
    if (!membership.data || membership.data.revoked) {
      return 0; // Not a member
    }
    
    const memberData = this.parseAttestationData(membership.data.value);
    totalPower += memberData.votingPower || 1;
    
    // 2. Add contribution-based power
    const contributions = await this.sdk.fetchAttestation({
      schemaUID: 'dao-contribution-v1',
      subject: voterAddress
    });
    
    if (contributions.data && !contributions.data.revoked) {
      const contribData = this.parseAttestationData(contributions.data.value);
      
      // Weight formula: 1 point per 10 contributions
      totalPower += Math.floor(contribData.totalContributions / 10);
      
      // Bonus for code contributions
      totalPower += contribData.codeCommits * 2;
      
      // Bonus for successful proposals
      totalPower += contribData.proposalsSubmitted * 3;
    }
    
    // 3. Apply reputation multiplier
    const reputation = await this.sdk.fetchAttestation({
      schemaUID: 'dao-reputation-v1',
      subject: voterAddress
    });
    
    if (reputation.data && !reputation.data.revoked) {
      const repData = this.parseAttestationData(reputation.data.value);
      
      // Reputation multiplier: 1.0x to 2.0x based on score
      const multiplier = 1 + (repData.score / 200); // Max 2x at 200 score
      totalPower = Math.floor(totalPower * multiplier);
    }
    
    // Cap maximum voting power
    return Math.min(totalPower, 100);
  }
  
  async castVote(
    voterAddress: string,
    proposalId: string,
    vote: 'for' | 'against' | 'abstain'
  ) {
    // Calculate voting power
    const votingPower = await this.calculateVotingPower(voterAddress);
    
    if (votingPower === 0) {
      throw new Error('No voting power');
    }
    
    // Record vote with weighted power
    await this.recordVote({
      proposalId,
      voter: voterAddress,
      vote,
      power: votingPower,
      timestamp: Date.now()
    });
    
    // Update participation metrics
    await this.updateParticipation(voterAddress);
    
    return {
      proposalId,
      vote,
      votingPower,
      txHash: 'vote_tx_hash'
    };
  }
  
  private async updateParticipation(memberAddress: string) {
    // Fetch current reputation
    const current = await this.sdk.fetchAttestation({
      schemaUID: 'dao-reputation-v1',
      subject: memberAddress
    });
    
    let reputation = {
      score: 50,
      participationRate: 0,
      proposalSuccess: 0,
      peerEndorsements: 0
    };
    
    if (current.data && !current.data.revoked) {
      reputation = this.parseAttestationData(current.data.value);
    }
    
    // Increment participation
    reputation.participationRate = Math.min(reputation.participationRate + 1, 100);
    reputation.score = Math.min(reputation.score + 1, 200);
    
    // Update reputation attestation
    await this.sdk.attest({
      schemaUID: 'dao-reputation-v1',
      subject: memberAddress,
      value: `score:${reputation.score},participationRate:${reputation.participationRate},proposalSuccess:${reputation.proposalSuccess},peerEndorsements:${reputation.peerEndorsements}`,
      reference: `reputation-update-${Date.now()}`
    });
  }
}
```

### Contribution Tracking

Track and reward member contributions:

```typescript
class ContributionTracker {
  async recordContribution(
    contributor: string,
    type: 'code' | 'proposal' | 'community' | 'content',
    details: any
  ) {
    // Fetch existing contributions
    const existing = await this.sdk.fetchAttestation({
      schemaUID: 'dao-contribution-v1',
      subject: contributor
    });
    
    let contributions = {
      totalContributions: 0,
      codeCommits: 0,
      proposalsSubmitted: 0,
      lastActive: 0
    };
    
    if (existing.data && !existing.data.revoked) {
      contributions = this.parseAttestationData(existing.data.value);
    }
    
    // Update based on contribution type
    contributions.totalContributions += 1;
    contributions.lastActive = Date.now();
    
    switch(type) {
      case 'code':
        contributions.codeCommits += 1;
        break;
      case 'proposal':
        contributions.proposalsSubmitted += 1;
        break;
    }
    
    // Issue updated attestation
    const attestation = await this.sdk.attest({
      schemaUID: 'dao-contribution-v1',
      subject: contributor,
      value: `totalContributions:${contributions.totalContributions},codeCommits:${contributions.codeCommits},proposalsSubmitted:${contributions.proposalsSubmitted},lastActive:${contributions.lastActive}`,
      reference: `contribution-${type}-${Date.now()}`
    });
    
    // Trigger rewards if applicable
    await this.checkContributionRewards(contributor, contributions);
    
    return attestation;
  }
  
  private async checkContributionRewards(contributor: string, contributions: any) {
    // Milestone-based rewards
    const milestones = [10, 50, 100, 500, 1000];
    
    if (milestones.includes(contributions.totalContributions)) {
      await this.issueReward(contributor, `milestone-${contributions.totalContributions}`);
    }
  }
}
```

### Cross-DAO Reputation

Enable portable reputation across DAOs:

```typescript
class CrossDAOReputation {
  async aggregateReputation(memberAddress: string): Promise<{
    totalScore: number;
    daos: Array<{
      dao: string;
      score: number;
      role: string;
    }>;
  }> {
    // Define participating DAOs
    const participatingDAOs = [
      { name: 'TechDAO', schema: 'techdao-reputation-v1' },
      { name: 'DeFiDAO', schema: 'defidao-reputation-v1' },
      { name: 'ArtDAO', schema: 'artdao-reputation-v1' }
    ];
    
    const reputations = await Promise.all(
      participatingDAOs.map(async (dao) => {
        const attestation = await this.sdk.fetchAttestation({
          schemaUID: dao.schema,
          subject: memberAddress
        });
        
        if (attestation.data && !attestation.data.revoked) {
          const data = this.parseAttestationData(attestation.data.value);
          return {
            dao: dao.name,
            score: data.score || 0,
            role: data.role || 'member'
          };
        }
        
        return null;
      })
    );
    
    const validReputations = reputations.filter(r => r !== null);
    const totalScore = validReputations.reduce((sum, r) => sum + r.score, 0);
    
    return {
      totalScore,
      daos: validReputations
    };
  }
  
  async issuePortableReputation(memberAddress: string) {
    const aggregated = await this.aggregateReputation(memberAddress);
    
    // Issue cross-DAO reputation attestation
    const attestation = await this.sdk.attest({
      schemaUID: 'cross-dao-reputation-v1',
      subject: memberAddress,
      value: `totalScore:${aggregated.totalScore},daoCount:${aggregated.daos.length},topDAO:${aggregated.daos[0]?.dao || 'none'}`,
      reference: `cross-dao-${Date.now()}`
    });
    
    return attestation;
  }
}
```

---

## Advanced Patterns

### Quadratic Voting

Implement quadratic voting with attestations:

```typescript
async function calculateQuadraticVotes(
  voterAddress: string,
  votesToCast: number
): Promise<{ cost: number; allowed: boolean }> {
  // Get voter's reputation score
  const reputation = await sdk.fetchAttestation({
    schemaUID: 'dao-reputation-v1',
    subject: voterAddress
  });
  
  if (!reputation.data || reputation.data.revoked) {
    return { cost: 0, allowed: false };
  }
  
  const repData = parseAttestationData(reputation.data.value);
  const maxVotes = Math.floor(Math.sqrt(repData.score)); // Square root of reputation
  
  if (votesToCast > maxVotes) {
    return { cost: 0, allowed: false };
  }
  
  // Quadratic cost: nÂ² tokens for n votes
  const cost = votesToCast * votesToCast;
  
  return { cost, allowed: true };
}
```

### Delegation with Attestations

Enable vote delegation:

```typescript
// Delegation schema
const delegationSchema = {
  name: 'vote-delegation-v1',
  definition: 'delegator:address,delegate:address,startTime:uint64,endTime:uint64,scope:string'
};

async function delegateVotingPower(
  delegator: string,
  delegate: string,
  duration: number = 30 * 24 * 60 * 60 * 1000 // 30 days
) {
  // Verify delegator has voting power
  const delegatorPower = await calculateVotingPower(delegator);
  
  if (delegatorPower === 0) {
    throw new Error('No voting power to delegate');
  }
  
  // Issue delegation attestation
  const attestation = await sdk.attest({
    schemaUID: 'vote-delegation-v1',
    subject: delegate,
    value: `delegator:${delegator},delegate:${delegate},startTime:${Date.now()},endTime:${Date.now() + duration},scope:all`,
    reference: `delegation-${delegator}-to-${delegate}`
  });
  
  return attestation;
}

// Check delegated voting power
async function getTotalVotingPower(voterAddress: string): Promise<number> {
  let totalPower = await calculateVotingPower(voterAddress);
  
  // Add delegated power
  const delegations = await sdk.fetchAttestation({
    schemaUID: 'vote-delegation-v1',
    subject: voterAddress
  });
  
  if (delegations.data && !delegations.data.revoked) {
    const delegationData = parseAttestationData(delegations.data.value);
    
    // Check if delegation is still valid
    if (Date.now() <= delegationData.endTime) {
      const delegatorPower = await calculateVotingPower(delegationData.delegator);
      totalPower += delegatorPower;
    }
  }
  
  return totalPower;
}
```

### Sybil Resistance

Implement proof of humanity requirements:

```typescript
async function verifySybilResistance(memberAddress: string): Promise<{
  isHuman: boolean;
  verificationMethods: string[];
}> {
  // Check multiple attestation types for Sybil resistance
  const checks = await Promise.all([
    // Proof of Humanity
    sdk.fetchAttestation({
      schemaUID: 'proof-of-humanity-v1',
      subject: memberAddress
    }),
    
    // Social verification
    sdk.fetchAttestation({
      schemaUID: 'social-verification-v1',
      subject: memberAddress
    }),
    
    // Biometric verification
    sdk.fetchAttestation({
      schemaUID: 'biometric-verification-v1',
      subject: memberAddress
    })
  ]);
  
  const verificationMethods = [];
  let verificationScore = 0;
  
  checks.forEach((check, index) => {
    if (check.data && !check.data.revoked) {
      const data = parseAttestationData(check.data.value);
      if (data.verified || data.isHuman) {
        verificationScore += 1;
        verificationMethods.push(['humanity', 'social', 'biometric'][index]);
      }
    }
  });
  
  return {
    isHuman: verificationScore >= 2, // Require at least 2 verification methods
    verificationMethods
  };
}
```

---

## Integration Examples

### Snapshot Integration

Integrate with Snapshot for off-chain voting:

```typescript
class SnapshotAttestationStrategy {
  async getVotingPower(
    space: string,
    network: string,
    provider: any,
    addresses: string[],
    options: any,
    snapshot: number
  ): Promise<Record<string, number>> {
    const scores: Record<string, number> = {};
    
    // Fetch attestations for all addresses
    const attestationPromises = addresses.map(async (address) => {
      const power = await this.calculateVotingPower(address);
      scores[address] = power;
    });
    
    await Promise.all(attestationPromises);
    
    return scores;
  }
  
  private async calculateVotingPower(address: string): Promise<number> {
    // Implementation matches DAO voting power calculation
    const dao = new AttestationDAO(sdk, 'dao_address');
    return await dao.calculateVotingPower(address);
  }
}
```

### On-Chain Governor

Implement on-chain governance with attestations:

```solidity
// Stellar/Soroban Governor Contract
use soroban_sdk::{contractimpl, Address, Env};

pub struct Governor;

#[contractimpl]
impl Governor {
    pub fn propose(
        env: Env,
        proposer: Address,
        description: String,
        actions: Vec<Action>
    ) -> Result<u64, Error> {
        // Verify proposer has required reputation
        let reputation = Self::get_reputation(&env, &proposer)?;
        
        if reputation < MIN_PROPOSAL_REPUTATION {
            return Err(Error::InsufficientReputation);
        }
        
        // Create proposal
        let proposal_id = Self::create_proposal(&env, proposer, description, actions)?;
        
        Ok(proposal_id)
    }
    
    pub fn cast_vote(
        env: Env,
        voter: Address,
        proposal_id: u64,
        support: u8
    ) -> Result<(), Error> {
        // Get voting power from attestations
        let voting_power = Self::get_voting_power(&env, &voter)?;
        
        if voting_power == 0 {
            return Err(Error::NoVotingPower);
        }
        
        // Record weighted vote
        Self::record_vote(&env, proposal_id, voter, support, voting_power)?;
        
        Ok(())
    }
}
```

---

## Testing Implementation

```typescript
describe('DAO Voting Integration', () => {
  let dao: AttestationDAO;
  let contributionTracker: ContributionTracker;
  let member: string;
  
  beforeEach(async () => {
    dao = new AttestationDAO(sdk, 'test_dao');
    contributionTracker = new ContributionTracker(sdk);
    member = 'test_member_address';
  });
  
  it('should grant membership and calculate voting power', async () => {
    // Grant membership
    await dao.grantMembership(member, 'contributor');
    
    // Add contributions
    await contributionTracker.recordContribution(member, 'code', {
      commits: 5,
      linesAdded: 500
    });
    
    // Calculate voting power
    const power = await dao.calculateVotingPower(member);
    
    expect(power).to.be.greaterThan(1); // More than base membership
  });
  
  it('should handle vote delegation', async () => {
    const delegator = 'delegator_address';
    const delegate = 'delegate_address';
    
    // Setup delegator with voting power
    await dao.grantMembership(delegator, 'member');
    
    // Delegate voting power
    await delegateVotingPower(delegator, delegate);
    
    // Check delegate's total power
    const delegatePower = await getTotalVotingPower(delegate);
    
    expect(delegatePower).to.include.delegated.power;
  });
});
```

---

## Best Practices

### Voting Power Caps

Prevent concentration of power:

```typescript
const VOTING_POWER_LIMITS = {
  individual: 100,        // Max 100 votes per individual
  percentageOfTotal: 0.05 // Max 5% of total voting power
};

async function applyVotingCaps(
  voterAddress: string,
  calculatedPower: number,
  totalDAOPower: number
): Promise<number> {
  // Apply individual cap
  let cappedPower = Math.min(calculatedPower, VOTING_POWER_LIMITS.individual);
  
  // Apply percentage cap
  const maxByPercentage = Math.floor(totalDAOPower * VOTING_POWER_LIMITS.percentageOfTotal);
  cappedPower = Math.min(cappedPower, maxByPercentage);
  
  return cappedPower;
}
```

### Participation Incentives

Reward active participation:

```typescript
async function calculateParticipationRewards(memberAddress: string) {
  const participation = await sdk.fetchAttestation({
    schemaUID: 'dao-participation-v1',
    subject: memberAddress
  });
  
  if (participation.data) {
    const data = parseAttestationData(participation.data.value);
    
    // Reward tiers based on participation rate
    if (data.participationRate >= 90) {
      return { tier: 'platinum', multiplier: 2.0 };
    } else if (data.participationRate >= 70) {
      return { tier: 'gold', multiplier: 1.5 };
    } else if (data.participationRate >= 50) {
      return { tier: 'silver', multiplier: 1.2 };
    }
  }
  
  return { tier: 'bronze', multiplier: 1.0 };
}
```

---

## Next Steps

- [Custom Schema Design](/guides/custom-schemas) - Create governance-specific schemas
- [Privacy Options](/guides/privacy-options) - Anonymous voting implementations
- [GitHub Credentials](/guides/github-credentials) - Developer DAO integrations
- [Cross-Chain Governance](/guides/cross-chain) - Multi-chain DAO setups