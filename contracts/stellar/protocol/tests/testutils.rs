// =======================================================================================
//
//                              BLS CRYPTOGRAPHY TEST HELPERS
//
// =======================================================================================
//! Test utilities for BLS12-381 cryptographic testing
//!
//! This module provides valid BLS12-381 curve points for testing signature verification
//! and other cryptographic operations. All constants are valid points on the curve.
use bls12_381::{G1Affine, G2Affine, Scalar};

#[test]
fn generate_valid_bls_constants() {
    // Generate G1 uncompressed (96 bytes)
    let g1_gen = G1Affine::generator();
    let g1_uncompressed = g1_gen.to_uncompressed();
    println!("G1 generator uncompressed (96 bytes):");
    print!("pub const TEST_BLS_G1_SIGNATURE: [u8; 96] = [");
    for (i, byte) in g1_uncompressed.iter().enumerate() {
        if i % 16 == 0 {
            print!("\n    ");
        }
        print!("0x{:02x}, ", byte);
    }
    println!("\n];");

    // Generate G2 uncompressed (192 bytes)
    let g2_gen = G2Affine::generator();
    let g2_uncompressed = g2_gen.to_uncompressed();
    println!("\nG2 generator uncompressed (192 bytes):");
    print!("pub const TEST_BLS_G2_PUBLIC_KEY: [u8; 192] = [");
    for (i, byte) in g2_uncompressed.iter().enumerate() {
        if i % 16 == 0 {
            print!("\n    ");
        }
        print!("0x{:02x}, ", byte);
    }
    println!("\n];");

    // Verify they're valid
    let g1_from_bytes = G1Affine::from_uncompressed(&g1_uncompressed).unwrap();
    let g2_from_bytes = G2Affine::from_uncompressed(&g2_uncompressed).unwrap();

    assert_eq!(g1_from_bytes, g1_gen);
    assert_eq!(g2_from_bytes, g2_gen);

    println!("\nâœ… All constants are valid BLS12-381 points!");
}

/// Valid BLS12-381 private key for testing (32 bytes)
/// This generates a deterministic keypair for consistent testing
pub const TEST_BLS_PRIVATE_KEY: [u8; 32] = [
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
];

/// Valid BLS12-381 G1 generator point (96 bytes uncompressed)
/// Generated using bls12_381 crate G1Affine::generator().to_uncompressed()
pub const TEST_BLS_G1_SIGNATURE: [u8; 96] = [
    0x17, 0xf1, 0xd3, 0xa7, 0x31, 0x97, 0xd7, 0x94, 0x2c, 0xd9, 0x65, 0xa7, 0xa3, 0x54, 0xe8, 0x21, 0xbe, 0x2e, 0x54,
    0x12, 0x5e, 0x83, 0x6c, 0x94, 0xc2, 0x79, 0x47, 0x2e, 0xce, 0x5f, 0x2a, 0x57, 0xaf, 0x28, 0x41, 0x39, 0x02, 0x28,
    0xe3, 0x36, 0x5a, 0x9e, 0x85, 0x5a, 0x43, 0xdd, 0x09, 0xcf, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01,
];

/// Valid BLS12-381 G2 generator point (192 bytes uncompressed)
/// Generated using bls12_381 crate G2Affine::generator().to_uncompressed()
pub const TEST_BLS_G2_PUBLIC_KEY: [u8; 192] = [
    0x13, 0xe0, 0x2b, 0x60, 0x52, 0x71, 0x9f, 0x60, 0x7d, 0xac, 0xd3, 0xa0, 0x88, 0x27, 0x4f, 0x65, 0x59, 0x6b, 0xd0,
    0xd0, 0x9d, 0x20, 0xd8, 0x5f, 0xd1, 0xa3, 0x9b, 0x6f, 0x49, 0x58, 0xa6, 0x9e, 0xdd, 0x81, 0xe0, 0x9f, 0x60, 0xf6,
    0x24, 0xc3, 0x6c, 0xed, 0x4c, 0x74, 0x49, 0xb5, 0x6a, 0x1b, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x6a, 0x18, 0xe0, 0xb4, 0x18, 0xeb, 0x48, 0x60, 0xfb, 0x32, 0x10, 0xbe, 0x86, 0x55, 0x63, 0x2d, 0xe2,
    0x12, 0xb0, 0x2a, 0x7a, 0x90, 0x3e, 0x60, 0x6d, 0xcd, 0x08, 0x4d, 0x72, 0xce, 0x60, 0x89, 0x4e, 0x11, 0x36, 0x14,
    0xb9, 0x72, 0x0f, 0xc0, 0xc2, 0x57, 0x93, 0x39, 0x2e, 0x99, 0x40, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
];

/// Helper function to generate valid BLS test keys at runtime
/// This creates actual valid cryptographic keys for testing
pub fn generate_valid_test_keypair() -> (G2Affine, Scalar) {
    let private_key = Scalar::from_bytes(&TEST_BLS_PRIVATE_KEY).unwrap();
    let public_key = G2Affine::generator() * private_key;
    (public_key.into(), private_key)
}

/// Helper function to get the G1 generator point
pub fn g1_generator() -> G1Affine {
    G1Affine::generator()
}

/// Helper function to get the G2 generator point  
pub fn g2_generator() -> G2Affine {
    G2Affine::generator()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_points() {
        // Verify our constants are valid points
        let g1_gen = g1_generator();
        let g2_gen = g2_generator();

        assert!(bool::from(g1_gen.is_on_curve()));
        assert!(bool::from(g1_gen.is_torsion_free()));
        assert!(bool::from(g2_gen.is_on_curve()));
        assert!(bool::from(g2_gen.is_torsion_free()));

        // Test keypair generation
        let (_pk, _sk) = generate_valid_test_keypair();
        println!("Public key: {:?}", _pk);
        println!("Private key: {:?}", _sk);
    }
}
